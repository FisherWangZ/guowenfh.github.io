<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三省吾身丶丶</title>
  <subtitle>兴趣遍地都是，专注和持之以恒才是真正稀缺的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guowenfh.github.io/"/>
  <updated>2016-11-27T15:35:24.000Z</updated>
  <id>http://guowenfh.github.io/</id>
  
  <author>
    <name>guowenfh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《自控力》笔记：意志力实验与深入剖析</title>
    <link href="http://guowenfh.github.io/2016/11/27/selfControlWorks/"/>
    <id>http://guowenfh.github.io/2016/11/27/selfControlWorks/</id>
    <published>2016-11-26T16:13:13.000Z</published>
    <updated>2016-11-27T15:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"><a href="#第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？" class="headerlink" title="第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"></a>第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？</h2><p><strong>意志力第一法则：认识你自己</strong></p>
<p>当我们做一件事的时候，我们能意识到自己在做什么，也知道我们为什么这样做。<br>但愿我们还能知道，在做这件事情之前我们需要做些什么，这样我们就会三思而后行。</p>
<p>核心思想：</p>
<ul>
<li>意志力实际上是“我要做”、“我不要”和“我想要”这三种力量。它们协同努力，让我们变成更好的自己。</li>
</ul>
<h3 id="深入剖析：更难的事是什么？"><a href="#深入剖析：更难的事是什么？" class="headerlink" title="深入剖析：更难的事是什么？"></a>深入剖析：更难的事是什么？</h3><ul>
<li><p>想象你正面临一个意志力的挑战。更难的事是什么？为什么它如此困难？</p>
</li>
<li><p>认清两个自我。你的意志力挑战是，如何描述相抗衡的两个自我？冲动的你想要什么？明智的你又想要什么？</p>
</li>
</ul>
<h3 id="意志力实验：-回忆一下你的决定"><a href="#意志力实验：-回忆一下你的决定" class="headerlink" title="意志力实验： 回忆一下你的决定"></a>意志力实验： 回忆一下你的决定</h3><p>如果你想有更强的自控力， 就得有更多的自我意识。</p>
<p>首先你得知道， 什么样的决定需要意志力。 有些决定比较明显， 比如“ 下班后要不要去健身？” 但有些冲动的后果可能要过些日子才会显现。比如， 你是不是先装好了运动背包， 以便不用回家就能去锻炼？（ 这是个不错的做法！ 这样你就没那么多借口了。） 你是不是接了个电话，然后聊着聊着就饿了， 没办法直接去健身了？（ 哎呀！ 你要是先去吃饭， 八成就不会去健身了。）</p>
<p>请至少选一天， 把你作的决定都记下来。在这一天结束的时候， 回想你作的决定， 分析哪些有利于你实现目标， 哪些会消磨你的意志。 坚持记录你的决定， 还有助于减少在注意力分散时作决定， 同时增强你的意志力。</p>
<h3 id="意志力实验：5分钟大脑冥想"><a href="#意志力实验：5分钟大脑冥想" class="headerlink" title="意志力实验：5分钟大脑冥想"></a>意志力实验：5分钟大脑冥想</h3><p>专心呼吸是一种简单有效的冥想技巧， 它不但能训练大脑， 还能增强意志力。<br>它能减轻你的压力， 指导大脑处理内在的干扰（ 比如冲动、 担忧、 欲望） 和外在的诱惑（ 比如声音、 画面、 气味）。 新研究表明， 定期的思维训练能帮人戒烟、 减肥、 戒毒、 保持清醒。 无论你“ 要做” 和“ 不要” 的是什么， 这种5分钟冥想都有助于你增强意志力。</p>
<p>1． 原地不动， 安静坐好。<br>坐在椅子上， 双脚平放在地上， 或盘腿坐在垫子上。 背挺直， 双手放在膝盖上。 冥想时一定不能烦躁， 这是自控力的基本保证。<br>如果你想挠痒的话， 可以调整一下胳膊的位置， 腿交叉或伸直， 看自己是否有冲动但能克制。 简单的静坐对于意志力的冥想训练至关重要。 你将学会， 不再屈服于大脑和身体产生的冲动。</p>
<p>2． 注意你的呼吸。<br>闭上眼睛。 要是怕睡着， 你可以盯着某处看， 比如盯着一面白墙， 但不要看家庭购物频道。 注意你的呼吸。 吸气时在脑海中默念“ 吸”，呼气时在脑海中默念“ 呼”。<br>当你发现自己有点走神的时候， 重新将注意力集中到呼吸上。 这种反复的注意力训练， 能让前额皮质开启高速模式，让大脑中处理压力和冲动的区域更加稳定。</p>
<p>3． 感受呼吸， 弄清自己是怎么走神的。<br>几分钟后， 你就可以不再默念“ 呼”、“ 吸” 了。试着专注于呼吸本身。会注意到空气从鼻子和嘴巴进入和呼出的感觉，感觉到吸气时胸腹部的扩张和呼气时胸腹部的收缩。<br>不再默念“ 呼”、“ 吸” 后， 你可能更容易走神。 像之前一样， 当你发现自己在想别的事情时， 重新将注意力集中到呼吸上。 如果你觉得很难重新集中注意力， 就在心里多默念几遍“ 呼” 和“ 吸”。<br>这部分的训练能锻炼你的自我意识和自控能力。刚开始的时候， 你每天锻炼5分钟就行。 习惯成自然之后， 请试着每天做10～ 15 分钟。<br>如果你觉得有负担， 那就减少到5分钟。 每天做比较短的训练， 也比把比较长的训练拖到明天好。 这样，你每天都会有一段固定的时间冥想， 比如早晨洗澡之前。 如果你做不到， 可以对时间进行适当的调整。</p>
<h2 id="第二周：意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"><a href="#第二周：意志力的本能：人生来就能抵制奶酪蛋糕的诱惑" class="headerlink" title="第二周：意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"></a>第二周：意志力的本能：人生来就能抵制奶酪蛋糕的诱惑</h2><h3 id="深入剖析：什么是威胁？"><a href="#深入剖析：什么是威胁？" class="headerlink" title="深入剖析：什么是威胁？"></a>深入剖析：什么是威胁？</h3><p>我们总觉得诱惑和麻烦来自外部世界，比如危险的甜甜圈、罪恶的香烟、充满诱惑的网络。但自控力告诉我们，问题出在我们自己身上，是我们的思想、欲望、情绪和冲动出了问题。对你的意志力挑战来说，最重要的是认清什么是需要克制的内在冲动。哪些想法或感觉迫使你在不情愿的时候作出决定？如果你不确定的话，可以作一些实地观察。</p>
<p>下一次你受到诱惑的时候，试着关注自己的内心世界(意志力本能：三思而后行,   “三思而后行”反应就是让你慢下来。当你意识到内在冲突的时候，大脑和身体会做出反应，帮助你放慢速度、抑制冲动。虽然“三思而后行”和应激反应都是人类天性中的一部分，想了解为何意志力本能不是总能生效，我们需要深入了解压力和自控力的生理学基础。)</p>
<h3 id="意志力实验：通过呼吸实现自控"><a href="#意志力实验：通过呼吸实现自控" class="headerlink" title="意志力实验：通过呼吸实现自控"></a>意志力实验：通过呼吸实现自控</h3><p>将呼吸频率降低到每分钟4～6次，也就是每次呼吸用10～15秒时间，比平常呼吸要慢一些。只要你有足够的耐心，加上必要的练习，这一点不难办到。放慢呼吸能激活前额皮质、提高心率变异度，有助于你的身心从压力状态调整到自控力状态。这样训练几分钟之后，你就会感到平静、有控制感，能够克制欲望、迎接挑战。(不要憋气)</p>
<h3 id="意志力实验：5分钟给意志力加油"><a href="#意志力实验：5分钟给意志力加油" class="headerlink" title="意志力实验：5分钟给意志力加油"></a>意志力实验：5分钟给意志力加油</h3><p>科学家认为，5分钟的“绿色锻炼”就能减缓压力、改善心情、提高注意力、增强自控力。“绿色锻炼”指的是任何能让你走到室外、回到大自然怀抱中的活动。好消息是，“绿色锻炼”有捷径可走。短时间的爆发可能比长时间的锻炼更能改善你的心情。以下是一些你在5分钟“绿色锻炼”中可以尝试的活动：</p>
<ul>
<li>走出办公室，找到最近的一片绿色空间。</li>
<li>用iPod播放一首你最喜欢的歌曲，在附近<br>街区慢跑。</li>
<li>和你的宠物狗在室外玩耍（你可以追着玩<br>具跑）。</li>
<li>在自家花园里找点事情做。</li>
<li>出去呼吸新鲜空气，做些简单的伸展活<br>动。</li>
<li>在后院里和孩子做游戏。</li>
</ul>
<p><strong>如果你觉得锻炼太累了，或是没有时间锻炼，那么不妨将锻炼当做恢复体能和意志力的方法。</strong></p>
<h3 id="意志力实验：呼噜呼噜睡个觉"><a href="#意志力实验：呼噜呼噜睡个觉" class="headerlink" title="意志力实验：呼噜呼噜睡个觉"></a>意志力实验：呼噜呼噜睡个觉</h3><p>睡出意志力！ 如果你每天睡眠时间不足6个小时，那你很可能记不起自己上一次意志力充沛是什么时候了。长期睡眠不足让你更容易感到压力、萌生欲望、受到诱惑。你还会很难控制情绪、集中注意力，</p>
<p>如果你现在缺乏睡眠，有很多方法都能帮助你恢复自控力。即使你不能每晚都连续睡上8小时，作一些小调整也会起到明显的效果。一些研究表明，一个晚上良好的睡眠就能帮助大脑恢复到最佳状态。所以，如果你已经一周都晚睡早起了，那么周末补个好觉就能让你恢复意志力。</p>
<p>其他研究指出，一周的前几天睡些好觉能帮你储备能量，这样就能对付后几天的睡眠不足了。另外还有一些研究表明，最重要的指标是你连续清醒的时间。即便你前一晚没有睡好，打个小盹也能让你重新集中注意力、恢复自控力。你可以尝试补觉、储存睡眠，或是打个小盹，这些策略都有助于减少睡眠不足带来的危害。</p>
<p>如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事！</p>
<p>想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</p>
<h3 id="意志力实验：放松能让你恢复意志力储备"><a href="#意志力实验：放松能让你恢复意志力储备" class="headerlink" title="意志力实验：放松能让你恢复意志力储备"></a>意志力实验：放松能让你恢复意志力储备</h3><p>从压力和自控力中恢复的最佳途径就是放松。放松，即便只放松几分钟，都能激活副交感神经系统，舒缓交感神经系统，从而提高心率变异度。它还能把身体调整到修复和自愈状态、提高免疫功能、降低压力荷尔蒙分泌。<br>想要激发这种放松反应，你需要躺下来，用枕头垫着膝盖，腿稍稍抬起（或者，你可以选择任何一个你觉得舒服的姿势）。闭上眼睛，做几次深呼吸，感觉你的腹部有起伏。如果你觉得身体某处很紧张，你可以有意识地挤压或收缩肌肉，然后就不要再去管它了。比如，如果你发现手掌和手指很紧张，那么就攥一下拳头，然后张开手掌。如果你发现前额和下巴很紧张，那么就挤挤眼、皱皱眉，然后张大嘴巴，放松整个面部。保持这种状态5～10分钟，试着享受这种除了呼吸什么都不用想的状态。如果你担心会睡着，那就先设定好闹钟。<br>你可以把这当成一项日常练习。尤其是当你处于高压环境中或者需要意志力的时候，都可以做这个练习。放松会让你的生理机能得以恢复，同时消除慢性压力和自控带来的影响。</p>
<h3 id="深入剖析：压力和自控-本周回顾"><a href="#深入剖析：压力和自控-本周回顾" class="headerlink" title="深入剖析：压力和自控 本周回顾"></a>深入剖析：压力和自控 本周回顾</h3><p>本周，我们研究了自控力的死敌——压力，心理上或生理上的压力。担忧和过度工作是如何影响你的选择的？饥饿和疲劳会不会消耗你的意志力？身体疼痛或疾病会不会消耗你的意志力？愤怒、孤单或悲伤的情绪会不会消耗你的意志力？试着找出持续一整天或一整周的压力，看看它对你的自控力产生怎样的影响。你有过强烈的欲望吗？你发脾气了吗？你把要做的事拖到了明天吗？</p>
<h2 id="第三周：累到无力抵抗：为什么自控力和肌肉一样有极限？"><a href="#第三周：累到无力抵抗：为什么自控力和肌肉一样有极限？" class="headerlink" title="第三周：累到无力抵抗：为什么自控力和肌肉一样有极限？"></a>第三周：累到无力抵抗：为什么自控力和肌肉一样有极限？</h2><h3 id="深入剖析：意志力波动"><a href="#深入剖析：意志力波动" class="headerlink" title="深入剖析：意志力波动"></a>深入剖析：意志力波动</h3><p>意志力的肌肉模式告诉我们，自控力从早上到晚上会逐渐减弱。这一周，试着观察自己在什么时候意志力最强，在什么时候最容易放弃。</p>
<p>你是不是起床的时候意志力十足，但这种意志力慢慢会消耗殆尽？或者，你有没有在其他时候觉得自己恢复了意志力，觉得神清气爽？你可以通过了解自己来更明智地规划日程，以便在意志力耗尽的时候克制住自己。</p>
<h3 id="意志力实验：意志力饮食方案"><a href="#意志力实验：意志力饮食方案" class="headerlink" title="意志力实验：意志力饮食方案"></a>意志力实验：意志力饮食方案</h3><p>突然增加的糖分会让你在短期内面对紧急情况时有更强的意志力。调整饮食也需要自控力，但哪怕你只做了一点改善（比如，每个工作日都吃一顿丰盛健康的早餐，而不是什么都不吃；吃零食时选择坚果，而不选择糖果），你获得的意志力都会比你消耗的多。</p>
<h3 id="意志力实验：锻炼意志力"><a href="#意志力实验：锻炼意志力" class="headerlink" title="意志力实验：锻炼意志力"></a>意志力实验：锻炼意志力</h3><p>如果你想彻底改变旧习惯，最好先找一种简单的方法来训练自控力、提高意志力，而不是设定一个过高的目标。</p>
<ol>
<li>增强“我不要”的力量：不随便发誓（或者不说某些口头禅）、坐下的时候不跷脚、用不常用的手进行日常活动，比如吃饭和开门。</li>
<li>增强“我想要”的力量：每天都做一些事（但不是你已经在做的事），用来养成习惯或不再找借口。你可以给母亲打电话、冥想5分钟，或是每天在家里找出一件需要扔掉或再利用的东西。</li>
<li>增强自我监控能力：认真记录一件你平常不关注的事，可以是你的支出、饮食，也可以是你花在上网和看电视上的时间。你不需要太先进的工具，铅笔和纸就够了.</li>
</ol>
<h3 id="深入剖析：你的疲惫感是真的吗？"><a href="#深入剖析：你的疲惫感是真的吗？" class="headerlink" title="深入剖析：你的疲惫感是真的吗？"></a>深入剖析：你的疲惫感是真的吗？</h3><p>我们总是一感到疲劳就放弃锻炼、对另一半厉言相加、把事情拖到下一秒、选择点比萨而不是做一顿健康的饭菜。可以肯定地说，生存的需要确实会耗尽我们的意志力，我们也不可能要求一个人有完美的自控力。但比起第一次感觉疲劳就放弃，你其实有更多的意志力。</p>
<p>下一次你觉得自己“疲惫”得没法自控的时候，试着挑战一下自己，挺过第一波疲惫感。不过，要注意不要训练过度。</p>
<h3 id="意志力实验：你的“我想要”的力量是什么？"><a href="#意志力实验：你的“我想要”的力量是什么？" class="headerlink" title="意志力实验：你的“我想要”的力量是什么？"></a>意志力实验：你的“我想要”的力量是什么？</h3><p>这一周，当你面临挑战的时候，问问自己，那一刻哪种动力最能让你坚持下去。你愿不愿意为了别人，而不是为了自己，去做那些困难的事？是对未来的憧憬，还是对命运的恐惧，推动你前进？当你发现了自己最重要的“我想要”的力量，发现了你脆弱时给你力量的东西之后，只要你觉得自己就要在诱惑前放弃了，就想想这个动力。挖掘你的“我想要”的力量，让自己恢复能量。</p>
<ol>
<li>如果挑战成功，你会收获什么？你个人会有什么回报？你会更健康、更幸福、更自由、更有钱，还是会更成功？</li>
<li>如果挑战成功，还有谁会获益？肯定有人依赖于你，你的选择会影响到他们。你的行为会如何影响你的家人、朋友、同事、雇主或雇员、街坊邻居？你的成功会怎样帮到他们？</li>
<li>如果你现在愿意做困难的事，那么一段时间后，这个挑战将会变容易。你能想象出，如果你在这个挑战中取得进步，你的生活会是什么样子，你自己会变成什么样子吗？如果你知道你还有更大的进步空间，现在的不适是不是变得值得了呢？</li>
</ol>
<h2 id="第四周-：容忍罪恶：为何善行之后会有恶行？"><a href="#第四周-：容忍罪恶：为何善行之后会有恶行？" class="headerlink" title="第四周 ：容忍罪恶：为何善行之后会有恶行？"></a>第四周 ：容忍罪恶：为何善行之后会有恶行？</h2><h3 id="深入剖析：善与恶"><a href="#深入剖析：善与恶" class="headerlink" title="深入剖析：善与恶"></a>深入剖析：善与恶</h3><p>先来看看我们总是在生活中的对于我们的行为所做的一个“道德许可”：如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。如果你去处理了一个重要项目就说自己很“好”，拖延着不去处理就说自己很“坏”，那么你很可能因为早上取得了进步，下午就变懒散了。简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。</p>
<p>这一周，试着观察你意志力挑战成功和失败的时候，你是怎么对自己和他人解释的。</p>
<ul>
<li>当你意志力挑战成功的时候，你会不会告诉自己你已经很“好”了？当你屈服于拖延症或某种诱惑的时候，你会不会告诉自己你太“坏”了？</li>
<li>你会不会以自己的善行为借口，允许自己去做些坏事？这是无害的奖励，还是阻碍了你实现更长远的意志力目标？</li>
</ul>
<h3 id="深入剖析：你是在向明天赊账吗？"><a href="#深入剖析：你是在向明天赊账吗？" class="headerlink" title="深入剖析：你是在向明天赊账吗？"></a>深入剖析：你是在向明天赊账吗？</h3><p>当你要作与意志力挑战有关的决定时，注意一下，你脑海中是否闪过了“未来再好好表现”的承诺。你是不是告诉自己，明天会弥补今天的过错？这对你当下的自控有什么影响？一直保持关注，从今天一直关注到明天。你是不是真的做到了你所说的？或者，“今天放纵，明天改变”的循环是不是又开始了？</p>
<h3 id="意志力实验：明天和今天毫无区别"><a href="#意志力实验：明天和今天毫无区别" class="headerlink" title="意志力实验：明天和今天毫无区别"></a>意志力实验：明天和今天毫无区别</h3><p>这一周就试着逐渐减少行为的变化性。把你今天作的每个决定都看成是对今后每天的承诺。<br>因此，不要问自己“我现在想不想吃这块糖？”，而要问自己“<strong>我想不想在一年里每天下午都吃一块糖？</strong>”或者，你明知道应该做一件事情却拖延不做时，不要问自己“我是想今天做还是明天做？”，而要问自己“我是不是想承担永远拖延下去的恶果？”</p>
<h3 id="深入剖析：你正在被光环笼罩吗？"><a href="#深入剖析：你正在被光环笼罩吗？" class="headerlink" title="深入剖析：你正在被光环笼罩吗？"></a>深入剖析：你正在被光环笼罩吗？</h3><p>你会不会因为关注一个事物最有益的品质，而允许自己沉溺于它？有没有什么“神奇词语”会给你放纵的许可？比如“买一送一”、“全天然”、“淡”、“公平贸易”、“有机”或“为了慈善”。只关注每张收据结尾处写的“你节省了___！”，却忽略了自己总共花了多少钱。</p>
<p>当“光环效应”影响到你的意志力挑战时，你需要找到最具体的测量标准（比如卡路里、花费、消耗或浪费的时间），以此判断这个选择是否和你的目标相符。</p>
<p>这一周，看看你是否被那些破坏长远目标的光环所笼罩。</p>
<h3 id="深入剖析：你觉得自己是谁？"><a href="#深入剖析：你觉得自己是谁？" class="headerlink" title="深入剖析：你觉得自己是谁？"></a>深入剖析：你觉得自己是谁？</h3><p>当你思考自己的意志力考验时，你觉得哪部分的你像“真实”的你？是那个想追求目标的你，还是那个需要被控制的你？你是更认同自己的冲动和欲望，还是更认同自己的长期目标和价值观？当你想到你的意志力挑战时，你觉得自己是能成功的人吗？还是说，你觉得自己需要被彻底压抑、完善或改变？</p>
<h3 id="意志力实验：取消许可，牢记理由。"><a href="#意志力实验：取消许可，牢记理由。" class="headerlink" title="意志力实验：取消许可，牢记理由。"></a>意志力实验：取消许可，牢记理由。</h3><p>如何关注对自己的承诺，而不是关注单纯的进步？当面对同一个诱惑时，回忆自己当时为什么拒绝了诱惑。这有助于帮助我们做出与自身目标相符的决定。</p>
<p>记住我们为什么会拒绝诱惑，这是个很有效的方法，一万年每当你面对自我放纵的诱惑时，记住这件事会改变我们的感觉。所谓的奖励看起来更像对于目标的威胁，屈服于诱惑的感觉并不好，记住理由还有助于你发现并抓住机遇以完成目标</p>
<p>下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励（你当时为什么能拒绝诱惑）。</p>
<h2 id="第五周：大脑的弥天大谎：为什么我们误把渴望当幸福？"><a href="#第五周：大脑的弥天大谎：为什么我们误把渴望当幸福？" class="headerlink" title="第五周：大脑的弥天大谎：为什么我们误把渴望当幸福？"></a>第五周：大脑的弥天大谎：为什么我们误把渴望当幸福？</h2><h3 id="深入剖析：是什么让你的多巴胺神经元不停燃烧？"><a href="#深入剖析：是什么让你的多巴胺神经元不停燃烧？" class="headerlink" title="深入剖析：是什么让你的多巴胺神经元不停燃烧？"></a>深入剖析：是什么让你的多巴胺神经元不停燃烧？</h3><p>多巴胺控制的是行动，而不是快乐。奖励的承诺保证了被试者成功地行动，从而获得奖励。当奖励系统活跃的时候，他们感受到的是期待，而不是快乐。<br>这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴（如果在喂狗之前摇铃，狗即便没有看到食物，也会听到铃声就流口水。它们懂得把铃声和晚餐的承诺联系在一起。克努森作出了一个大胆的预测。他认为，大脑在期待奖励的时候也会“流口水”。），或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？<br>虽然我们所处的世界总让我们产生欲望，但我们只要用心观察，就能看透一些东西。知道那是怎么一回事并不能完全消除你的欲望，但它能让你至少有机会抗争一下，锻炼一下“我不要”力量。</p>
<h3 id="深入剖析：谁在控制你的多巴胺神经元？"><a href="#深入剖析：谁在控制你的多巴胺神经元？" class="headerlink" title="深入剖析：谁在控制你的多巴胺神经元？"></a>深入剖析：谁在控制你的多巴胺神经元？</h3><p>让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。</p>
<h3 id="意志力实验：为了你的“我愿意”挑战分泌多巴胺"><a href="#意志力实验：为了你的“我愿意”挑战分泌多巴胺" class="headerlink" title="意志力实验：为了你的“我愿意”挑战分泌多巴胺"></a>意志力实验：为了你的“我愿意”挑战分泌多巴胺</h3><p>人们一直以来都在用奖励承诺来克服癖好。学生通过使用音乐、时尚杂志和电视，让自己在做通常会推迟的任务时，产生更多多巴胺，帮助他们找到了解决办法，比如带上可怕的文书工作走进自己喜欢的咖啡厅，边喝热巧克力边完成工作，或是极富创意地买一堆刮刮乐彩票，把它们放在你想拖延的项目周围。</p>
<p>还有一些人想象自己努力工作后取得的最佳结果，让未来的奖励显得更加真实。如果有什么事让你觉得很不愉快，所以你总是拖延着不去做，你能不能把它和能让多巴胺神经元燃烧的事联系在一起，从而促使自己去做呢？</p>
<h3 id="深入剖析：欲望的压力"><a href="#深入剖析：欲望的压力" class="headerlink" title="深入剖析：欲望的压力"></a>深入剖析：欲望的压力</h3><p>大部分人会更关注对快乐的承诺，而不关注多巴胺刺激欲望时感觉到的不快乐。这一周，看看你能否发现渴望会引发压力和焦虑。如果你屈服于诱惑的话，你觉得这是自己对奖励承诺的反应？还是在缓解焦虑？</p>
<h3 id="意志力实验：测试奖励的承诺"><a href="#意志力实验：测试奖励的承诺" class="headerlink" title="意志力实验：测试奖励的承诺"></a>意志力实验：测试奖励的承诺</h3><p>找一个常常让你放纵自己的诱惑因素，测试一下奖励的承诺。你之所以会受到诱惑，是因为大脑告诉你，你会很快乐。<br>学生们最常见的选择是零食、购物、电视和电子邮件、纸牌游戏等和网络相关的浪费时间的事情。请<strong>关注你放纵的过程</strong>，不要急着去体验。<strong>注意这种奖励的承诺给你什么感觉</strong>。期待、希望、兴奋、焦虑、流口水……你的大脑和身体感觉到了什么。然后，允许自己接受诱惑。和你的期望比起来，这种体验怎么样？奖励的承诺有没有消失？它是否仍然促使你吃得更多、花得更多、待得更久？什么时候你会感到满足？你是否达到了一种没法继续的程度，因为你太饱了、太累了、太沮丧了、没时间了，或是无法得到“奖励”了？</p>
<p>进行这项练习的人通常会有两种结果。一些人会发现，当他们真的关注放纵的感受时，他们实际上并不需要自己想象中那么多的东西。另外一些人发现，这种体验完全无法让他们满足。这就暴露了奖励的承诺和实际体验之间的差别。这两种观察都会让你对曾经无法控制的事有更强的自控力。</p>
<h2 id="第六周：“那又如何”：情绪低落为何会使人屈服于诱惑？"><a href="#第六周：“那又如何”：情绪低落为何会使人屈服于诱惑？" class="headerlink" title="第六周：“那又如何”：情绪低落为何会使人屈服于诱惑？"></a>第六周：“那又如何”：情绪低落为何会使人屈服于诱惑？</h2><p>情绪低落会使人屈服，而且经常是以令人吃惊的方式屈服。女性在感到焦虑或抑郁的时候，很有可能会去吃巧克力，但她们这一解压方法的唯一效果，就是带来更大的罪恶感。</p>
<h3 id="深入剖析：缓解压力的承诺"><a href="#深入剖析：缓解压力的承诺" class="headerlink" title="深入剖析：缓解压力的承诺"></a>深入剖析：缓解压力的承诺</h3><p>当你感到压力、焦虑或心情低落的时候，你会怎么做呢？你生气时会不会更容易受到诱惑？你是不是会更难集中注意力，或更容易拖延呢？情绪低落是如何影响你的意志力挑战的？</p>
<h3 id="意志力实验：尝试一种有效的解压方法"><a href="#意志力实验：尝试一种有效的解压方法" class="headerlink" title="意志力实验：尝试一种有效的解压方法"></a>意志力实验：尝试一种有效的解压方法</h3><ul>
<li>最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。</li>
</ul>
<ul>
<li>最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网 、花两小时以上看电视或电影。</li>
</ul>
<p>有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质。当我们面对压力时，大脑一再做出错误的预测，不知道什么才能让我们快乐。也就是说，我们经常阻止自己去做真正能带来快乐的事。下一回，当你面对压力，即将作出缓解压力的承诺时，可以考虑尝试一下更有效的解压方法。</p>
<p>思考：有没有什么东西能提醒面对压力的你？到底什么才能让你感到更快乐？在你感到压力之前，你能不能先想出一些鼓励自己的方法？</p>
<h3 id="深入剖析：是什么吓到了你？"><a href="#深入剖析：是什么吓到了你？" class="headerlink" title="深入剖析：是什么吓到了你？"></a>深入剖析：是什么吓到了你？</h3><p>这一周，请注意观察什么事情会引发你大脑里的“恐惧管理”。是你在媒体或网络上听到或看到的东西吗？你会在社区运动场上感染新型食肉细菌吗？非洲杀人蜂这次会从哪里飞过来？哪栋大楼被炸了？哪里发生了致命车祸？谁惨死在家中？（如果你想再多学点东西的话，还可以看看商家怎么利用你的恐惧宣传他们的产品。它们和你的意志力挑战有关系吗？）别人还可能怎么利用你的恐惧，让你产生对安慰的渴望？                 </p>
<p>请花上24个小时，远离那些会让你产生恐惧的电视新闻、访谈节目、杂志或网页。如果你觉得自己不关注那些正在发生的大事小事，世界末日也不会降临的话，就请别在这些媒体上毫无意义地消磨时光了。</p>
<h3 id="深入剖析：遇到挫折时"><a href="#深入剖析：遇到挫折时" class="headerlink" title="深入剖析：遇到挫折时"></a>深入剖析：遇到挫折时</h3><p>这一周，请特别留意你是<strong>如何应对意志力失效的</strong>。</p>
<p>你会责备自己，告诉自己你永远不会改变吗？你会觉得这样的挫折暴露了你的问题——懒惰、愚蠢、贪婪或无能吗？你会感到绝望、罪恶、羞愧、愤怒或不知所措吗？你会以挫折为借口，更加放纵自己吗？</p>
<h3 id="意志力实验：失败的时候，请原谅自己"><a href="#意志力实验：失败的时候，请原谅自己" class="headerlink" title="意志力实验：失败的时候，请原谅自己"></a>意志力实验：失败的时候，请原谅自己</h3><p>每个人都会犯错误，都会遭遇挫折。我们总是倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。既然失败无法避免，更重要的就是我们如何应对失败，以下是心理学家提供的一些方法:</p>
<ol>
<li>你感觉如何？当你想到挫折时，花一点时间关注并描述你此刻的感觉。你现在情绪如何？你有什么感觉？你是否记得自己失败后的第一感觉？你会怎样描述那种感觉？注意一下那种感觉是不是自我责备。如果是的话，你对自己说了什么？自知的视角让你看清自己的感受，而且不会急于逃避。</li>
<li>你只是个凡人。每个人都会遇到意志力挑战，每个人都有失去自控的时候。这只是人性的组成部分，挫折并不意味着你本身有问题。想一想这些说法是不是真的。你能想象你尊敬、关心的其他人也经历过同样的抗争和挫折吗？这个视角会让自我批评和自我怀疑的声音变得不那么尖锐。</li>
<li>你会跟朋友说什么？想一想，如果你的好朋友经历了同样的挫折，你会怎么安慰他？你会说哪些鼓励的话？你会如何鼓励他继续追求自己的目标？这个视角会为你指明重归正途之路。</li>
</ol>
<h3 id="深入剖析：决定改善心情"><a href="#深入剖析：决定改善心情" class="headerlink" title="深入剖析：决定改善心情"></a>深入剖析：决定改善心情</h3><p>请花一点时间，仔细想一想你改变自己的动力和期望。你只有在情绪低落时才会有动力改变吗？想象成功改变生活时的快乐，是不是你作出改变的唯一动力？你会通过幻想未来的自己来改善现在的心情，而不是采取实际行动改善自己的行为吗？</p>
<h3 id="意志力实验：乐观的悲观主义者更可能成功"><a href="#意志力实验：乐观的悲观主义者更可能成功" class="headerlink" title="意志力实验：乐观的悲观主义者更可能成功"></a>意志力实验：乐观的悲观主义者更可能成功</h3><p>乐观给我们动力，但少许的悲观能帮我们走向成功。研究发现，如果能预测自己什么时候、会如何受到诱惑和违背承诺，你就更有可能拥有坚定的决心。</p>
<p>想一想你自己的意志力挑战，请扪心自问：我什么时候最可能受到诱惑并放弃抗争？什么东西最可能分散我的注意力？当我允许自己拖延的时候，我会怎样劝说自己？当你头脑中出现这样的情景时，想象自己真的处在这样的情景中，你会有什么感觉？会想到什么？让你自己看一看典型的意志力失效是怎么发生的。</p>
<p>然后，把想象中的意志力失效变成现实中的意志力成功。想一想你要采取哪些具体行动来坚定自己的决心。你需要回忆一下自己的动力吗？需要远离诱惑吗？需要找朋友帮忙吗？需要用你学过的其他意志力策略吗？当你头脑中有了一个具体策略后，想象一下你正在这样做，再想象一下这会有什么感觉。想象自己成功了，让这种想象给你自信，相信自己为了完成目标会不惜一切。</p>
<p>用这种方法预见失败其实是一种自我同情的方式，而不是自我怀疑的方式。当你真的受到诱惑的时候，你就能有所准备，能将自己的计划付诸实践。</p>
<h2 id="第七周：出售未来：及时享乐的经济学"><a href="#第七周：出售未来：及时享乐的经济学" class="headerlink" title="第七周：出售未来：及时享乐的经济学"></a>第七周：出售未来：及时享乐的经济学</h2><p>“延迟折扣”：等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。加上2分钟的延迟，6颗巧克力豆还比不上2颗能马上获得的巧克力豆。随着巧克力豆离我们越来越远，每颗巧克力豆的价值都缩水了。解释了为什么我们宁愿放弃未来的幸福，也要选择即刻的快感。</p>
<h3 id="深入剖析：你给未来的奖励打了几折？"><a href="#深入剖析：你给未来的奖励打了几折？" class="headerlink" title="深入剖析：你给未来的奖励打了几折？"></a>深入剖析：你给未来的奖励打了几折？</h3><p>对你的意志力挑战来说，当你屈服于诱惑或拖延的时候，你是把哪些未来的奖励出售了？放弃抗争的即时回报是什么？长期的代价是什么？这是公平交易吗？如果理性的你说“不，那是个叫人讨厌的买卖”，那么，请你试着去捕捉自己改变选择的时刻。是什么想法和感觉让你出售了未来？</p>
<h3 id="意志力实验：等待10分钟"><a href="#意志力实验：等待10分钟" class="headerlink" title="意志力实验：等待10分钟"></a>意志力实验：等待10分钟</h3><p>想获得一个冷静明智的头脑，我们就需要在所有诱惑面前安排10分钟的等待时间。如果10分钟后你仍旧想要，你就可以拥有它。但在10分钟之内，你一定要时刻想着长远的奖励，以此抵抗诱惑。如果可以的话，你也可以创造一些物理上（或视觉上）的距离。</p>
<p>如果你的意志力挑战需要“我要做”的力量，</p>
<p>你仍旧可以使用这个“10分钟法则”，以此来克服诱惑和拖延。你可以把法则改成“<strong>坚持做10分钟，然后就可以放弃</strong>”。当10分钟结束后，你就可以允许自己停下来。不过你会发现，只要一开始，你就会想继续做下去。</p>
<h3 id="意志力实验：降低你的折扣率"><a href="#意志力实验：降低你的折扣率" class="headerlink" title="意志力实验：降低你的折扣率"></a>意志力实验：降低你的折扣率</h3><p>幸运的是，一个人的折扣率不是始终不变的物理法则。通过改变自己对选择的看法，我们就能降低折扣率.当人们首先想到未来的奖励时，未来奖励的折扣率就会大幅下降。无论面对什么样的诱惑，你都可以利用以下方式抵抗即时的满足感。</p>
<ol>
<li>当你受到诱惑要做与长期利益相悖的事时，请想象一下，这个选择就意味着，你为了即时的满足感放弃了更好的长期奖励。</li>
<li>想象你已经得到了长期的奖励。想象未来的你正在享受自控的成果。</li>
<li>然后扪心自问：你愿意放弃它，来换取正在诱惑你的短暂快感吗？</li>
</ol>
<h3 id="意志力实验：对未来的自己作预先承诺"><a href="#意志力实验：对未来的自己作预先承诺" class="headerlink" title="意志力实验：对未来的自己作预先承诺"></a>意志力实验：对未来的自己作预先承诺</h3><p>你准备好对未来受诱惑的自己施加压力了吗？这一周，为未来某一刻的自己作出承诺。从以下策略中挑选一个，在你的意志力挑战中用上它。</p>
<ol>
<li>作好拒绝诱惑的准备。在未来的自我被诱惑蒙蔽之前，提前作出选择。比如，你可以在饿得对外卖菜单流口水之前，先打包一份健康午餐。无论是个人锻炼还是看牙医，你都可以作好计划并预先付款。为了未来的自己按理性偏好行事时更容易些，你能为意志力挑战做些什么？</li>
<li>让改变偏好变得更难。就像科尔蒂斯“破釜沉舟”一样，不要让自己轻易屈服于诱惑。在家里或办公室里摆脱诱惑。当你购物的时候，不要带信用卡，只带你想花掉的现金。把闹钟放在房间的另一端，你想要关闹钟就必须起床。这些做法都不能保证你绝对不会改变想法，但至少能让作出改变变得很困难。当你受到诱惑的时候，你能不能制造延迟或设置障碍，给自己一些时间来应对诱惑？</li>
<li>激励未来的自己。如果你在用胡萝卜或大棒督促自己获得健康和快乐，那么你不用觉得羞愧。人们向未来的自己预先作出承诺，从而实现改变。找一个方法，让你得到即时快感时付出更大的代价。你可以给即时的奖励“加税”，比如告诉自己会增加体重，或在没完成预定目标时向慈善机构捐款。奖励的价值可能没有变化，但屈服的代价会让即时的快感显得不再诱人。</li>
</ol>
<h3 id="深入剖析：你在等待未来的自己吗？"><a href="#深入剖析：你在等待未来的自己吗？" class="headerlink" title="深入剖析：你在等待未来的自己吗？"></a>深入剖析：你在等待未来的自己吗？</h3><p>你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？</p>
<h3 id="意志力实验：遇见未来的自己"><a href="#意志力实验：遇见未来的自己" class="headerlink" title="意志力实验：遇见未来的自己"></a>意志力实验：遇见未来的自己</h3><ol>
<li>创造一个未来的记忆。想象未来可以让人延迟满足感。你甚至不需要去想延迟满足感带给未来的回报，只要设想一下未来就行。比如，如果你正面临一个抉择，是现在就开始一个项目，还是推迟一下再开始，那么，想象一下你下周在杂货店里购物，或者想象一下你正在开预定的会议。当你想象未来的图景时，大脑就会更具体、更直接地思考你现在选择的结果。你想象的未来图景越真实、越生动，你做的决定就越不会让你在未来后悔。</li>
<li>给未来的自己发条信息。选择未来的某个时间点，把这些邮件发出去。为什么不利用这个机会想一想未来的自己在做什么，他们会如何看待自己现在作出的选择呢？向未来的自己描述一下自己现在将要做什么，有助于你实现长期目标。你对未来的自己有什么希望？你觉得自己会变成什么样？你也可以想象未来的自己回头看现在的自己。未来的自己会因为现在的自己做了什么而表示感激？</li>
<li>想象一下未来的自己。研究发现，想象未来的自己能增强你现在的意志力。在一个实验中，宅男宅女们需要想象两个未来的自己。第一个是他们希望成为的自己。那个人能坚持锻炼，身体健康，充满能量。第二个是他们害怕成为的自己。那个人懒散度日，毫无活力，体弱多病。这两种想象都能让他们离开椅子，和没有想象未来自己的对照组相比，这些人在两个月后提高了锻炼频率。在你的意志力挑战中，你能想象一个你希望成为的自己，一个能承诺改变并获得成果的自己吗？或者，你能想象一个背负不改变带来的恶果的自己吗？让你的白日梦做得更生动，更有细节。想象一下你会有什么样的感觉，你看上去会是什么样的，你会对过去的选择有什么感觉。你是会感到自豪、心怀感激，还是会后悔不迭？</li>
</ol>
<h3 id="深入剖析：为了你自己好，你是不是太“高瞻远瞩”了？"><a href="#深入剖析：为了你自己好，你是不是太“高瞻远瞩”了？" class="headerlink" title="深入剖析：为了你自己好，你是不是太“高瞻远瞩”了？"></a>深入剖析：为了你自己好，你是不是太“高瞻远瞩”了？</h3><p>你是否有过这样的感觉：因为总有更多的事情要做，似乎没办法放下工作休息一下？你是否对花钱产生了太多的罪恶感和焦虑感，以至于除了购买生活必需品，你觉得自己很难再去买别的东西？你有没有回头看过，自己是怎样花费时间和金钱的？你会不会希望当时你能更关注即时的快乐，而不是总去推迟享受？如果是这样的话，试一试本章提到的意志力实验，把它们当做放纵自己的方法。（别再试着推迟了，好不好？)</p>
<h2 id="第八周：传染：为什么意志力会传染？"><a href="#第八周：传染：为什么意志力会传染？" class="headerlink" title="第八周：传染：为什么意志力会传染？"></a>第八周：传染：为什么意志力会传染？</h2><h3 id="深入剖析：你的社交"><a href="#深入剖析：你的社交" class="headerlink" title="深入剖析：你的社交"></a>深入剖析：你的社交</h3><p>不是每个意志力挑战都是社会“传染”的结果，但大多数挑战都存在社会“传染”的问题。针对你自己的意志力挑战，请考虑以下问题：</p>
<ul>
<li>在你的社交圈中，有没有其他人有和你一样的意志力挑战？</li>
<li>回想一下，你有没有从朋友或家人身上学到过某种习惯？</li>
<li>和某些人在一起的时候，你会不会更容易放纵自己？</li>
<li>在你的社交圈中，最近有没有其他人也在尝试应对这个意志力问题？</li>
</ul>
<h3 id="深入剖析：你在模仿谁？"><a href="#深入剖析：你在模仿谁？" class="headerlink" title="深入剖析：你在模仿谁？"></a>深入剖析：你在模仿谁？</h3><p>这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？</p>
<p>马克最近找了个新工作，在咖啡店里做服务员。咖啡店每4个小时换一次班，员工能休息10分钟。马克很快发现，休息时大多数人会去后院抽烟。换班结束的时候，大家通常是从后院走进来的。回家前，大家也是边聊天边抽烟。马克平时不太抽烟，不过聚会时偶尔会抽一两根。他发现，自己休息的时候，如果其他服务员也在后院，他就会抽烟。有时候下班后，他也会和同事们在一起抽烟。</p>
<h3 id="意志力实验：增强你的免疫系统"><a href="#意志力实验：增强你的免疫系统" class="headerlink" title="意志力实验：增强你的免疫系统"></a>意志力实验：增强你的免疫系统</h3><p>我们不总是感染别人的目标。有时，看着别人屈服于诱惑，反而能增强我们的自控力。当你坚定了一个目标时（比如减肥），还要意识到你有一个与之冲突的目标（比如吃个比萨）。当你看到别人的行为和自己最大的目标发生冲突时，你的大脑就会处于高度警惕的状态。它会让你的主要目标更坚定，它还会寻找策略帮你坚守目标。心理学家把这叫做“反抗控制”。但当你的自控力受威胁时，你可以把它看做一种免疫反应。</p>
<p>当你面对别人的目标时，增强免疫系统的最佳途径就是：在每天刚开始的时候花几分钟想想自己的目标，想想你会怎么受到诱惑，想要改变自己的目标。这就像疫苗一样，能保护你不受别人的感染。回想自己的目标能强化这个目标，避免你感染他人的目标。</p>
<h3 id="意志力实验：感染自控力"><a href="#意志力实验：感染自控力" class="headerlink" title="意志力实验：感染自控力"></a>意志力实验：感染自控力</h3><p>研究发现，想到自控力强的人可以增强自己的意志力。对你的挑战来说，谁能成为你的意志力榜样呢？是那些经历过同样的挑战并最终成功的人，还是那些自控力的典范？（在我的班上，最常被提名的意志力模范是成功的运动员、精神领袖和政治家。但实际上，家人和朋友能给予我们更多的动力。我们接下来就会发现这个问题。）当你需要多一点意志力的时候，想想你的榜样。问问自己：那个意志力强人会怎么做？</p>
<h3 id="深入剖析：你最可能被谁感染？"><a href="#深入剖析：你最可能被谁感染？" class="headerlink" title="深入剖析：你最可能被谁感染？"></a>深入剖析：你最可能被谁感染？</h3><p>花一点时间去想一想，谁是和你关系密切的人。你和谁在一起的时间最长？你最尊重谁？你觉得谁和自己最像？谁的意见对你来说最重要？你最信任谁，最关心谁？你能不能想到哪些行为（无论是有益的还是有害的）是你从他们身上学来的，或是他们从你身上学到的？</p>
<h3 id="深入剖析：可别人都这么做！"><a href="#深入剖析：可别人都这么做！" class="headerlink" title="深入剖析：可别人都这么做！"></a>深入剖析：可别人都这么做！</h3><p>如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范</p>
<h3 id="意志力实验：自豪的力量"><a href="#意志力实验：自豪的力量" class="headerlink" title="意志力实验：自豪的力量"></a>意志力实验：自豪的力量</h3><p>想象一下你在意志力挑战中取得成功后会多么自豪。这样，你就能充分利用“被认可”这个人类的基本需求。想一想你所在“群体”中的某个人，可以是一个家庭成员、一个朋友、一个同事、一个老师。想象他们的观点与你相符，或者他们会为了你的成功感到高兴。当你作出一个让自己感到自豪的选择时，你可以更新Facebook的个人状态，或是在Twitter上发布信息。如果你不喜欢高科技产品，你也可以和人们面对面地分享自己的故事。</p>
<h3 id="意志力实验：把它变成集体项目"><a href="#意志力实验：把它变成集体项目" class="headerlink" title="意志力实验：把它变成集体项目"></a>意志力实验：把它变成集体项目</h3><p>你无须单独面对你的意志力挑战。有没有朋友、家人或同事可以和你一起实现意志力目标？你们不必有相同的目标，只需要相互记录和鼓励。这就能让你们在自控时感到来自社会的支持。如果你愿意把这种支持变成一种良性竞争，你也可以在意志力竞争中赢过别人。看看谁会最先完成被延误的任务，看看谁在一个月里节省的钱最多。</p>
<h2 id="第九周：“我不要”力量的局限性"><a href="#第九周：“我不要”力量的局限性" class="headerlink" title="第九周：“我不要”力量的局限性"></a>第九周：“我不要”力量的局限性</h2><p>正如我们所见，越是不让我们想一件事，我们就会越去想它。对焦虑、沮丧、节食、上瘾的最新调查证实，把“我不要”的力量用在涉及思想、情感的内心世界，它就会失效。当深入内心世界时，我们会发现，我们需要给自控一个全新的定义，给放弃自控留出一点空间来。</p>
<p>当人们试着不去想某件事时，反而会比没有控制自己的思维时想得更多，比自己有意去想的时候还要多。这个效应在人处于紧张、疲劳或烦乱状态时最为严重。韦格纳把这个效应称为“讽刺性反弹”.“讽刺性反弹”可以解释了现代人的很多失败事例：失眠患者越想入睡，就发现自己越清醒；减肥的人拒绝碳水化合物，却梦到了沃登面包和澳洲坚果曲奇；忧心忡忡的人试图摆脱焦虑，却一次又一次陷入对灾难的幻想。</p>
<h3 id="深入剖析：讽刺性反弹调查"><a href="#深入剖析：讽刺性反弹调查" class="headerlink" title="深入剖析：讽刺性反弹调查"></a>深入剖析：讽刺性反弹调查</h3><p>你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。）</p>
<h3 id="意志力实验：忠于你的感受，但别相信你所有的想法"><a href="#意志力实验：忠于你的感受，但别相信你所有的想法" class="headerlink" title="意志力实验：忠于你的感受，但别相信你所有的想法"></a>意志力实验：忠于你的感受，但别相信你所有的想法</h3><p>关注自己的想法，而不是试着转移注意力。通常情况下，最让人心烦的事都很相似——同样的担忧、同样的自我批评、同样的不堪回首。“如果出了问题怎么办？”“我真不相信我做了那个，我真笨！”“要是那件事没发生，我会做成某件事吗？”这些想法会像脑海里的歌曲一样突然出现。</p>
<p>它们都不是你需要相信的重要信息！接下来，把注意力转移到你的身体感受上，看看你是否会感觉紧张，心率或呼吸是否有变化，看看你的肠胃、胸腔、咽喉或其他身体部位是否有感觉。一旦观察到这些想法和感觉，就把注意力转移到呼吸上。感觉一下你是怎么吸气、呼气的。有时候，这些烦心的想法和感觉会随着呼吸自然消散。其他时候，它们将不停打断你对呼吸的关注。如果出现了这种情况，就把这些想法和感觉想象成飘过脑海和身体的浮云。不要停下呼吸，想象这些浮云不断消散或飘过。把呼吸想象成一阵风，它毫不费力地将这些浮云吹散、吹走。你无须让这些想法离开，只需保持呼吸的感觉。</p>
<p>注意，这种方法和相信或思考某个想法是不同的。不要抑制想法，接受它的存在，但不要相信它。你要接受的想法是：这些想法总是来来去去，你无法控制会出现什么想法，但你不必接受它的内容。换言之，你可以对自己说：“好吧，那种想法又来了，又得心烦。不过，这就是思维的运作方式，它并不一定意味着什么。”但不要对自己说：“好吧，我想这是真的。我真是个糟糕的人，糟糕的事会发生在我身上，我想我要接受这一点。”</p>
<p>同样的方法也可以用于应对使人分心或心烦意乱的各种情绪，比如愤怒、嫉妒、焦虑或羞愧。在多次尝试这种方法后，比较一下这么做的结果和努力摆脱心烦想法和情绪得到的结果，看看哪种方法更能给你带来内心的平静？无论是拖延症患者想摆脱焦虑，还是酗酒者想避免孤独，摆脱不好的感觉往往会导致自我毁灭的行为。挑战一下你的意志力，有没有什么你不想体验的感觉？如果你允许自己去体验，调节呼吸并想象浮云，会发生什么事？</p>
<h3 id="深入剖析：你最渴望什么？"><a href="#深入剖析：你最渴望什么？" class="headerlink" title="深入剖析：你最渴望什么？"></a>深入剖析：你最渴望什么？</h3><p>科学研究表明，当我们自我抑制，禁食一种食物时，我们反而会对它有难以抑制的欲望。你是否有这样的体验呢？你试过通过不吃一系列食物或你最喜欢的零食来减肥吗？如果你试过，你坚持了多久？你最后坚持下去了吗？你现在禁食什么东西吗？如果有，禁食是不是使你更渴望这些东西呢？如果你没有节食过，你是否曾经被禁止做什么事呢？被禁止做某件事会消除你对它的欲望，还是会激起你更大的渴望？</p>
<h3 id="意志力实验：直面自身欲望，但不要付诸行动"><a href="#意志力实验：直面自身欲望，但不要付诸行动" class="headerlink" title="意志力实验：直面自身欲望，但不要付诸行动"></a>意志力实验：直面自身欲望，但不要付诸行动</h3><p>在好时巧克力实验中，实验组织者告诉那些知道“白熊”现象和“反弹”理论的学生，在接下来一周里可以用以下4个步骤来应对自己强烈的欲望。这些欲望可以是巧克力、卡布奇诺咖啡或不停查收电子邮件。</p>
<ol>
<li>承认自己脑海中的欲望，以及渴望某种事物的感觉。</li>
<li>不要马上试着转移注意力或与之争论。接受这种想法或感觉，提醒自己“白熊”现象和“反弹”理论。</li>
<li>退一步考虑，意识到这种想法和感觉并不受你控制，但你可以选择是否将这些想法付诸实践。</li>
<li>记住你的目标，提醒自己预先作出的承诺。正如那些学生会提醒自己，他们答应过不偷吃巧克力。</li>
</ol>
<h3 id="意志力实验：把“我不要”变成“我想要”"><a href="#意志力实验：把“我不要”变成“我想要”" class="headerlink" title="意志力实验：把“我不要”变成“我想要”"></a>意志力实验：把“我不要”变成“我想要”</h3><p>当你面对“我不要”的巨大意志力挑战时，可以试着采取以下策略。</p>
<p>除了“我不要”，你还能做什么来满足同样的需求？许多坏习惯都是为了满足一定的需求而形成的，这些需求可能是减少压力、获得愉悦，也可能是寻求认同。你可以关注这些需求，用有同样效果的健康的新习惯来戒掉坏习惯。我的一位学生想戒咖啡，所以就用喝茶来代替喝咖啡。茶和咖啡有几乎相同的作用，能给你休息的机会，能提神，能端着到处跑，而且不用摄入那么多咖啡因。</p>
<p>如果没有了坏习惯，你还能做些什么？你可以做其他有趣的事来代替坏习惯。大多数的癖好和消遣需要从生活的其他部分抽调大量时间和精力。有时，关注错失的机会比试着戒掉坏习惯更有激励作用。我的一位学生是电视真人秀的发烧友。但当她为自己设定了“提高厨艺”的目标时，她就成功关掉了电视，并把更多时间放在琢磨厨艺上。（她成功的第一步就是用厨艺节目代替真人秀，接着从沙发上移动到厨房里进行实践。）</p>
<p>可以通过重新定义“我不要”的挑战，把它变成“我想要”的挑战吗？有时，同样的行为会被两种截然不同的思想支配。举个例子来说，我的一位学生<strong>把“不要迟到”重新定义为“做第一个到的人”或“提前5分钟到”。</strong>这或许听起来没有太大的不同，但他发现，自己变得更有动力了，也没那么容易迟到了。因为，他把“按时到达”变成了一场他能获胜的比赛。如果你关注自己想做什么，而不是自己不想做什么，你就可以避免“反弹”效应带来的危害。</p>
<p>如果你想做这个实验，请先花一周时间来关注你想做什么，而不是你不想做什么。在这周的最后，想一想你在旧的“我不要”挑战和新的“我想要”挑战中分别表现如何。</p>
<h3 id="意志力实验：驾驭冲动"><a href="#意志力实验：驾驭冲动" class="headerlink" title="意志力实验：驾驭冲动"></a>意志力实验：驾驭冲动</h3><p>无论你对什么上瘾，“驾驭冲动”的技巧都能帮你抵抗诱惑，而不是屈服于它。当冲动占据你的头脑时，花至少一分钟去感觉自己的身体。你的冲动是什么样的？是热的还是冷的？身体有没有感到不舒服？心率、呼吸或内脏有什么变化？保持这个状态至少一分钟。看看这些感觉在强度或特性上有什么变化。就像小孩子发脾气的时候一样，拒绝按照自己的冲动行事，有时会增加一个人的紧张程度。试着接受这些感觉，而不是试图否认它们。当你使用“驾驭冲动”的技巧时，呼吸是很有帮助的。你可以去感觉呼吸，体验吸入和呼出每一口气时的感觉，在此过程中了解自己的冲动。</p>
<p>当你第一次采用这个策略时，你可能一时驾驭住了冲动，但后来又故态复萌。在鲍文的吸烟研究中，每个人走出“刑讯室”后都马上抽起了烟。如果你在最初几次尝试中失败了，别灰心，这并不意味着这种方法是无效的。“驾驭冲动”和其他自控的新方法一样，都需要时间。你是否想在冲动来临之前就使用这项技巧？你可以正襟危坐，看看自己什么时候产生了冲动，想要抓鼻子、跷个腿或动一下。用同样的方法来驾驭这时的冲动，去感受它，但不要随冲动行事</p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>出于科学探索的精神，每回“意志力科学”课程结束的时候，我都会问学生们，在他们观察到的事情和尝试过的实验里，什么给他们留下了最深刻的印象。最近，我的一位科学家朋友建议我说，谈及科学的书最合适的结语莫过于——得出你自己的结论。所以，即便我很想写一段最后的总结，我还是要训练一下“我不要”的力量。我只向大家提出以下几个问题：</p>
<ul>
<li>你对意志力和自控力的想法是否有所改变？</li>
<li>你认为哪个意志力实验对你最有帮助？</li>
<li>你看到哪一页的时候最吃惊？</li>
<li>你从这本书里学到了什么？</li>
</ul>
<p>在未来的人生道路上，请保持科学家的心态。尝试新鲜事物，收集自己的数据，根据证据作出判断。对出人意料的想法保持开放的心态，从失败和成功中汲取经验教训。坚持有效的方法，和他人分享你了解的知识。面对复杂的人性和现代社会的诱惑，我们最好能做到这几点。但是，如果我们能保持好奇心和自我同情，那对付它们就绰绰有余了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot;&gt;&lt;a href=&quot;#第一周：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot; class=&quot;headerlink&quot; title=&quot;第一周：我要做，我不要，我想要：什么是意志力？为
    
    </summary>
    
      <category term="读书" scheme="http://guowenfh.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="摘录" scheme="http://guowenfh.github.io/tags/%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>人是不断思考成长的</title>
    <link href="http://guowenfh.github.io/2016/10/30/thoughtReport-2016-10-30/"/>
    <id>http://guowenfh.github.io/2016/10/30/thoughtReport-2016-10-30/</id>
    <published>2016-10-30T14:40:04.000Z</published>
    <updated>2016-11-23T05:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a>引子：</h2><p>和一个朋友聊天，说到为什么一直没谈恋爱。然后了解到她不想找同龄的男生，因为同龄的男生大多数都不够成熟，她不想又做恋人又做妈妈，教一个小男孩怎么成熟怎样长大。这样太累，也走不远。</p>
<p>如遭雷击，然后想起来一本小说里有一个类似的对话：</p>
<p>问：“XX，其实喜欢你的追求者当中还是有好孩子的，为什么不接受？”</p>
<p>答：“我知道他们喜欢我什么，但我不想做花瓶，被谁摆在家里当摆设，更不想又做恋人又做妈妈，教一个小男孩怎么成熟怎样长大。”</p>
<p>这算是一个新时代优秀独立女性的自述？</p>
<hr>
<h2 id="正题："><a href="#正题：" class="headerlink" title="正题："></a>正题：</h2><p>突然明白为什么总是会阶段性的颓唐，因为自己定下的小目标总是做不到，因为总是做一些自己明知道不该做的事情把定下的事情抛诸脑后，因为其实自己还在学着长大成熟。</p>
<p>原来一直没有遇到一个真的把做的每一件事情都上升到战术，战略层面来，即使是玩游戏/运动别人抱着娱乐的心态，他从来不是。一个清晰可量化的指标，用变态的执行力，不把时间浪费无用之处。这样的人定下的目标永远会比其他的人更快完成。现实中是真有这样的人存在的。</p>
<p>有时候在怎么学习上花了太多时间，而不是在学习上花同样甚至更多的时间, 这样是不正确的。</p>
<p>吾日三省吾身，尽快的调整目前一个人的生活学习状态，思考事情的处理方式，把握好自己心脑海中的想法，坚定向前。</p>
<p>想要得到一件东西就必须付出相应的努力。想得到什么应该只有自己知道。</p>
<p>克制、坚持。</p>
<p>不断修行到坚硬</p>
<p>2016/10/30</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子：&quot;&gt;&lt;a href=&quot;#引子：&quot; class=&quot;headerlink&quot; title=&quot;引子：&quot;&gt;&lt;/a&gt;引子：&lt;/h2&gt;&lt;p&gt;和一个朋友聊天，说到为什么一直没谈恋爱。然后了解到她不想找同龄的男生，因为同龄的男生大多数都不够成熟，她不想又做恋人又做妈妈，教一个
    
    </summary>
    
      <category term="生活" scheme="http://guowenfh.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂记" scheme="http://guowenfh.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>http 模块</title>
    <link href="http://guowenfh.github.io/2016/10/15/node-http/"/>
    <id>http://guowenfh.github.io/2016/10/15/node-http/</id>
    <published>2016-10-15T04:38:52.000Z</published>
    <updated>2016-11-26T16:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个网站的加载流程粗略的流程大概如下：</p>
<ol>
<li>用户通过浏览器发送一个http的请求到指定的主机</li>
<li>服务器接收到该请求，对该请求进行分析和处理</li>
<li>服务器处理完成以后，返回对应的数据到用户机器</li>
<li>浏览器接收服务器返回的数据，并根据接收到的进行分析和处理</li>
</ol>
<h2 id="最简单的web服务器"><a href="#最简单的web服务器" class="headerlink" title="最简单的web服务器"></a>最简单的web服务器</h2><p>我们需要搭建一个 <code>http</code> 的服务器，用于处理用户发送的 <code>http</code> 请求，在 node 中有 <code>http</code> 核心模块可以在很简单的几句话就帮我们启动一个服务器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入http模块:</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="comment">// 创建http server，并传入回调函数:</span></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="comment">// 回调函数接收request和response对象,</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'有客户端请求了.....'</span>);</div><div class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></div><div class="line">    response.write(<span class="string">'&lt;h1&gt;hello World!&lt;/h1&gt;'</span>);</div><div class="line">    response.end();</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 让服务器监听8888端口:</span></div><div class="line">server.listen(<span class="number">8888</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8888/'</span>);</div></pre></td></tr></table></figure></p>
<p>就这几行代码，我们就搭建了一个简单服务器，当我们将其运行，访问地址能在浏览器中显示我们熟悉的 <code>hello World!</code>,迈出了第一步。</p>
<p>下面我们来看看几个重要的地方：</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="创建与监听"><a href="#创建与监听" class="headerlink" title="创建与监听"></a>创建与监听</h3><p>首先我们来看创建<code>http server</code>的代码：</p>
<ul>
<li><code>var server = http.createServer([requestListener])</code> :创建并返回一个HTTP服务器对象<ul>
<li><code>requestListener</code> : 监听到客户端连接的回调函数<br>在这里可以看到我们的回调函数是可选的，我们还可以使用事件监听器来进行，监听到客户端连接之后的操作,如：<br><code>server.on(&#39;request&#39;, function(req, res) {// do ....})</code><br>我们要在用户访问时做一些什么，都会在这里。</li>
</ul>
</li>
</ul>
<p>再看监听端口的代码，在这里我们只是简单的写了一下监听的端口，它的可选项都没有去设置</p>
<ul>
<li><code>server.listen(port, [hostname], [backlog], [callback])</code> :监听客户端连接请求,只有当调用了 <code>listen</code> 方法以后,服务器才开始工作<ul>
<li><code>port</code> : 监听的端口</li>
<li><code>hostname</code> : 主机名(IP/域名),可选</li>
<li><code>backlog</code> : 连接等待队列的最大长度,可选</li>
<li><code>callback</code> : 调用listen方法并成功开启监听以后,会触发一个 listening事件,callback将作为该事件的执行函数,可选</li>
</ul>
</li>
</ul>
<p>看完了创建与监听的方法，我们再看看看，我们在监听到客户端连接的回调函数 <code>server.on(&#39;request&#39;, function(req, res) {// do ....})</code> 中看到有两个参数 request 和 response ，<br>在这两个参数中，我们可以去获得用户的当前请求一些信息,比如头信息,数据等待，还可以向该次请求的客户端输出返回响应，下面我们一起看看它里面的内容</p>
<h3 id="request-对象"><a href="#request-对象" class="headerlink" title="request 对象"></a>request 对象</h3><p>参数<code>request</code>对象是 <code>http.IncomingMessage</code> 的一个实例,通过它 ，我们可以获取到这次请求的一些信息,比如头信息,数据，<code>url</code>参数等等<br>这里简单的列一下最常见的:</p>
<ul>
<li><code>httpVersion</code>: 使用的http协议的版本</li>
<li><code>headers</code>: 请求头信息中的数据</li>
<li><code>url</code>: 请求的地址</li>
<li><code>method</code>: 请求方式</li>
</ul>
<h3 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h3><p>参数 <code>response</code>对象是 <code>http.ServerResponse</code>(这是一个由HTTP服务器内部创建的对象) 的一个实例，通过它 我们可以向该次请求的客户端输出返回响应。</p>
<ul>
<li><code>response.writeHead(statusCode, [reasonPhrase], [headers])</code>：向请求回复响应头，这个方法只能在当前请求中使用一次，并且必须在<code>response.end()</code>之前调用。<ul>
<li><code>statusCode</code>： 一个三位数的HTTP状态码, 例如 404</li>
<li><code>reasonPhrase</code>：自行设置http响应状态码对应的原因短语</li>
<li><code>headers</code>：响应头的内容</li>
</ul>
</li>
<li><code>write(chunk, [encoding])</code> : 发送一个数据块到响应正文中 ,如果这个方法被调用但是 <code>response.writeHead()</code> 没有被调用，<br>  它将切换到默认header模式并更新默认的headers。chunk可以是字符串或者缓存。如果chunk 是一个字符串，<br>  第二个参数表明如何将这个字符串编码为一个比特流。默认的 encoding是’utf8’。</li>
<li><code>end([data], [encoding])</code>: 当所有的正文和头信息发送完成以后,调用该方法告诉服务器数据已经全部发送完成了。<br>  <strong>这个方法在每次完成信息发送以后必须调用,并且是最后调用</strong>,如果指定了参数 data , 就相当于先调用<code>response.write(data, encoding)</code>之后再调用 <code>response.end()</code></li>
<li><code>setHeader(name, value)</code>: 为默认或者已存在的头设置一条单独的头信息：如果这个头已经存在于 将被送出的头中，将会覆盖原来的内容。如果我想设置更多的头， 就使用一个相同名字的字符串数组<br>  如：<code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></li>
</ul>
<p>看了那么多api，是时候实践一把了，我们再来对原来的代码进行一点改造～</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入http模块,url 模块</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</div><div class="line"><span class="comment">// 创建http server</span></div><div class="line"><span class="keyword">var</span> server = http.createServer();</div><div class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> urlObj = url.parse(req.url);</div><div class="line">    <span class="comment">//根据用户访问的url不同展示不同的页面</span></div><div class="line">    <span class="keyword">switch</span> (urlObj.pathname)&#123;</div><div class="line">        <span class="comment">// 这是首页</span></div><div class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</div><div class="line">            res.write(<span class="string">'&lt;h1&gt;这是里首页&lt;/h1&gt;'</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'/user'</span>:</div><div class="line">            res.write(<span class="string">'&lt;h1&gt;这里是个人中心&lt;/h1&gt;'</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span> :</div><div class="line">            res.write(<span class="string">'&lt;h1&gt;你要找的页面不见了～&lt;/h1&gt;'</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></div><div class="line">    res.end();</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8888</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8888/'</span>);</div></pre></td></tr></table></figure>
<p>启动一下该js文件，并且通过不同的url不同的后缀,如 <code>/</code> 和 <code>/user</code> 去访问这个地址，看看浏览器的输出，应该已经变了。</p>
<p>这就是通过简单的的url处理，来实现的路由机制拉～</p>
<h2 id="url-处理响应不同-html"><a href="#url-处理响应不同-html" class="headerlink" title="url 处理响应不同 html"></a>url 处理响应不同 html</h2><p>当然这里我们再继续深入一下！结合 node 的文件系统（fs模块），使不同的url，直接读取不同的 html 文件,示例：</p>
<p>准备工作: 在当前文件目录下建立<code>html</code>文件夹, 并且新增文件 <code>index.html</code>与 <code>user.html</code>，内容自行发挥</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer();</div><div class="line"><span class="comment">// 读取我们当前文件所在的目录下的 html 文件夹</span></div><div class="line"><span class="keyword">var</span> HtmlDir = __dirname + <span class="string">'/html/'</span>;</div><div class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> urlObj = url.parse(req.url);</div><div class="line">    <span class="keyword">switch</span> (urlObj.pathname) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</div><div class="line">            <span class="comment">//首页</span></div><div class="line">            sendData(HtmlDir + <span class="string">'index.html'</span>, req, res);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'/user'</span>:</div><div class="line">            <span class="comment">//用户首页</span></div><div class="line">            sendData(HtmlDir + <span class="string">'user.html'</span>, req, res);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">//处理其他情况</span></div><div class="line">            sendData(HtmlDir + <span class="string">'err.html'</span>, req, res);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取html文件，响应数据，发送给浏览器</div><div class="line"> * @param &#123;String&#125; file 文件路径</div><div class="line"> * @param &#123;Object&#125; req request</div><div class="line"> * @param &#123;Object&#125; res response 对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">file, req, res</span>) </span>&#123;</div><div class="line">    fs.readFile(file, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            res.writeHead(<span class="number">404</span>, &#123;</div><div class="line">                <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></div><div class="line">            &#125;);</div><div class="line">            res.end(<span class="string">'&lt;h1&gt;你要找的页面不见了～&lt;/h1&gt;'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">                <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></div><div class="line">            &#125;);</div><div class="line">            res.end(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">server.listen(<span class="number">8888</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8888/'</span>);</div></pre></td></tr></table></figure>
<p>运行文件，切换url，程序会将不同的页面返回。大家自己去试试吧！</p>
<p>这是对于 node 的 http模块 的学习，理解有限，如果有错误之处，请指出，谢谢！</p>
<p>本文地址：<a href="https://guowenfh.github.io/2016/10/15/node-http/">https://guowenfh.github.io/2016/10/15/node-http/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个网站的加载流程粗略的流程大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户通过浏览器发送一个http的请求到指定的主机&lt;/li&gt;
&lt;li&gt;服务器接收到该请求，对该请求进行分析和处理&lt;/li&gt;
&lt;li&gt;服务器处理完成以后，返回对应的数据到用户机器&lt;/li&gt;
&lt;li&gt;浏览器接收服务
    
    </summary>
    
      <category term="node" scheme="http://guowenfh.github.io/categories/node/"/>
    
    
      <category term="nodejs" scheme="http://guowenfh.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>node 文件系统</title>
    <link href="http://guowenfh.github.io/2016/10/15/node-file-system/"/>
    <id>http://guowenfh.github.io/2016/10/15/node-file-system/</id>
    <published>2016-10-15T04:12:48.000Z</published>
    <updated>2016-10-15T04:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>该模块是核心模块，需要使用 require 导入后使用</p>
</blockquote>
<h3 id="底层方法"><a href="#底层方法" class="headerlink" title="底层方法"></a>底层方法</h3><ol>
<li><code>fs.open(path, flags, [mode], callback)</code>:异步版的文件读取<ul>
<li><code>path</code>: 要打开的文件的路径</li>
<li><code>flags</code>: 打开文件的方式 读/写，12种不同方式？</li>
<li><code>mode</code>: 设置文件的模式 前提是这个文件是已存在的，读/写/执行  4/2/1</li>
<li><code>callback</code>: 回调<ul>
<li><code>err</code> : 文件打开失败的错误保存在err里面，如果成功err为null</li>
<li><code>fd</code> : 被打开文件的标识，和定时器</li>
</ul>
</li>
</ul>
</li>
<li><code>fs.openSync(path, flags, [mode])</code>:fs.open() 的同步版，返回值为 <code>fd</code></li>
<li><code>fs.read(fd, buffer, offset, length, position, callback)</code>:从指定的文档标识符 <code>fd</code> 读取文件数据。<ul>
<li><code>fd</code>: 通过open方法成功打开一个文件返回的编号</li>
<li><code>buffer</code>: buffer对象, 缓冲区，数据将会写入这里。</li>
<li><code>offset</code>: 新的内容添加到buffer中的起始位置,向缓冲区 buffer 写入的偏移量。</li>
<li><code>length</code>： 添加到buffer中内容的长度</li>
<li><code>position</code>：读取的文件中的起始位置,为null，将会从文件当前的位置读取数据。</li>
<li><code>callback</code>: 回调<ul>
<li><code>err</code>:错误</li>
<li><code>bytesRead</code>:buffer的长度，读取的字节</li>
<li><code>buffer</code>: buffer对象</li>
</ul>
</li>
</ul>
</li>
<li><code>fs.readSync(fd, buffer, offset, length, position)</code>:fs.read()的同步版，返回 <code>bytesRead</code></li>
<li><code>fs.write(fd, buffer, offset, length[, position], callback)</code>:通过文件标识fd，向指定的文件中写入buffer通过文件标识fd，向指定的文件中写入buffer.<br> /<code>fs.write(fd, data[, position[, encoding]], callback)</code>:通过指定的fd把data写入到文档中.<ul>
<li><code>fd</code>: 打开的文件标识</li>
<li><code>buffer</code> : 要写入的数据</li>
<li><code>offset</code> : buffer对象中要写入的数据的起始位置</li>
<li><code>length</code> : 要写入的buffer数据的长度</li>
<li><code>data</code>: 如果data不是buffer对象的实例则会把值强制转化成一个字符串。</li>
<li><code>position</code>: 是参考当前文档光标的位置，然后从该处写入数据。</li>
<li><code>encoding</code>: 是预期得到一个字符串编码</li>
<li><code>callback</code>:回调函数 (err, written, string)</li>
</ul>
</li>
<li><code>fs.writeSync(fd, buffer, offset, length[, position])</code>/<code>fs.writeSync(fd, data[, position[, encoding]])</code></li>
<li><code>fs.close(fd, callback)</code>:关闭一个打开的文件</li>
<li><code>fs.closeSync(fd)</code>: fs.close() 的同步版本</li>
</ol>
<h3 id="更易用的方法"><a href="#更易用的方法" class="headerlink" title="更易用的方法"></a>更易用的方法</h3><ol>
<li><code>fs.writeFlie(filename, data, [options], callback)</code>:<br>异步的将数据写入一个文件,如果文件不存在则新建, 如果文件原先存在，会被替换。<ul>
<li><code>filename</code> : 文件路径，</li>
<li><code>data</code> : data 可以是一个string，也可以是一个原生buffer。</li>
<li><code>options</code> : 选项<ul>
<li><code>encoding</code> :文件编码default = ‘utf8’</li>
<li><code>mode</code> : default = 438 (aka 0666 in Octal)</li>
<li><code>flag</code> : default = ‘a’</li>
</ul>
</li>
<li><code>callback</code> : 回调函数</li>
</ul>
</li>
<li><code>fs.writeFileSync(filename, data, [options])</code>：fs.writeFile的同步版本。</li>
<li><code>fs.appendFile(filename, data, [options], callback)</code>：异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新的文件。<ul>
<li><code>filename</code> : 文件路径，</li>
<li><code>data</code> : data 可以是一个string，也可以是一个原生buffer。</li>
<li><code>options</code> : 选项<ul>
<li><code>encoding</code> :文件编码default = ‘utf8’</li>
<li><code>mode</code> : default = 438 (aka 0666 in Octal)</li>
<li><code>flag</code> : default = ‘a’</li>
</ul>
</li>
<li><code>callback</code> : 回调函数</li>
</ul>
</li>
<li><code>fs.appendFileSync(filename, data, [options])</code>:fs.appendFile的同步版本。</li>
<li><code>fs.exists(path, callback)</code>:检查指定路径的文件或者目录是否存在。<ul>
<li><code>path</code>:路径</li>
<li><code>callback</code>: callback 传入的参数指明存在 (true) 或者不存在 (false).</li>
</ul>
</li>
<li><code>fs.existsSync(path)</code>:fs.exists 函数的同步版。</li>
<li><code>fs.readFile(filename, [options], callback)</code>:异步读取一个文件的全部内容<ul>
<li><code>filename</code>:文件路径</li>
<li><code>options</code>:<ul>
<li><code>encoding</code>:  default = null,如果未指定编码方式，原生buffer就会被返回。</li>
<li><code>flag</code>: default = ‘r’</li>
</ul>
</li>
<li><code>callback</code> :(err, data), data 就是文件的内容</li>
</ul>
</li>
<li><code>fs.readFileSync(filename, [options])</code>:fs.readFile的同步版本。 返回文件名为 filename 的文件内容。</li>
<li><code>fs.unlink(path, callback)</code>:删除一个文件,回调函数（callback）只接受一个参数：可能出现的异常信息.</li>
<li><code>fs.unlinkSync(path):fs.unlink()</code>: 的同步版本</li>
<li><code>fs.rename(oldPath, newPath, callback)</code>:异步版本的重命名函数.完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.</li>
<li><code>fs.renameSync(oldPath, newPath)</code>:fs.rename() 的同步版本 </li>
<li><code>fs.stat(path, callback)</code>:读取文件的状态信息,callback,接收两个参数： (err, stats) ，其中 stats 是一个 fs.Stats 对象。 </li>
<li><code>fs.statSync(path, callback)</code>:fs.stat() 的同步版本,返回一个 fs.Stats 实例。</li>
<li><code>fs.watch(filename, [options], [callback])</code>:观察指定路径的改变，filename 路径可以是文件或者目录。<br>回调函数得到两个参数 (event, filename)。其中 event 是 ‘rename’（重命名）或者 ‘change’（改变），而 filename 则是触发事件的文件名。</li>
</ol>
<h3 id="文件夹处理"><a href="#文件夹处理" class="headerlink" title="文件夹处理"></a>文件夹处理</h3><ol>
<li><code>fs.mkdir(path, [mode], callback)</code> :创建文件夹，回调函数只接受一个参数：可能出现的异常信息。－－－》<code>fs.mkdirSync(path, [mode])</code>同步版</li>
<li><code>fs.rmkdir(path, callback)</code>:删除文件夹，回调函数只接受一个参数：可能出现的异常信息。－－－》<code>fs.rmdirSync(path)</code>同步版</li>
<li><code>fs.readdir(path, callback)</code>:读取 path 路径所在文件夹的内容。<br> 回调函数 (callback) 接受两个参数 (err, files) 其中 files 是一个存储目录中所包含的文件名称的数组，数组中不包括 ‘.’ 和 ‘..’</li>
<li><code>fs.readdirSync(path)</code>:同步版的 readdir(). 返回文件名数组，其中不包括 ‘.’ 和 ‘..’ 目录.</li>
</ol>
<p>这是对于 node 的文件系统 的学习，仅仅过了一遍api，了解了一下处理流程，理解有限，如果有错误之处，请指出，谢谢！</p>
<p>本文地址：<a href="https://guowenfh.github.io/2016/10/15/node-file-system/">https://guowenfh.github.io/2016/10/15/node-file-system/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;该模块是核心模块，需要使用 require 导入后使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;底层方法&quot;&gt;&lt;a href=&quot;#底层方法&quot; class=&quot;headerlink&quot; title=&quot;底层方法&quot;&gt;&lt;/a&gt;底层方法&lt;/h3&gt;&lt;ol
    
    </summary>
    
      <category term="node" scheme="http://guowenfh.github.io/categories/node/"/>
    
    
      <category term="nodejs" scheme="http://guowenfh.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>process 对象与 Buffer 类</title>
    <link href="http://guowenfh.github.io/2016/10/15/node-global-object/"/>
    <id>http://guowenfh.github.io/2016/10/15/node-global-object/</id>
    <published>2016-10-15T03:40:29.000Z</published>
    <updated>2016-10-15T04:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在上一篇博客中，我们一起对于 node 的模块机制有了一点点的了解，当时我们就知道了在 node 中的全局对象是 <code>global</code> 而不是浏览器中的 <code>window</code> 它们有一部分属性方法是相同的，<br>比如：<code>clearInterval</code> / <code>clearTimeout</code> / <code>setInterval</code> / <code>setTimeout</code> / <code>console</code>。他们的用法和在浏览器中的用法是一样的，接下来我们就来看看那些在 node 中所特有全局属性和方法。</p>
</blockquote>
<p>我们先来稍微跑个题，看看与上一个篇博客的中介绍的 模块系统相关 的两个属性，还是可以模块的路径有关：</p>
<ul>
<li><code>__filename</code> : 返回 <strong>当前模块文件</strong>解析后的绝对路径</li>
<li><code>__dirname</code> : 返回 <strong>当前模块文件所在目录</strong> 解析后的绝对路径</li>
</ul>
<p><strong>注意：它们可以直接使用，但是实际上并非全局的，而是在模块作用域下的</strong></p>
<p>直接在文件内输入，运行即可输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(__filename);</div><div class="line"><span class="built_in">console</span>.log(__dirname);</div></pre></td></tr></table></figure></p>
<h2 id="process-对象"><a href="#process-对象" class="headerlink" title="process 对象"></a><code>process</code> 对象</h2><h3 id="process-对象的属性和方法"><a href="#process-对象的属性和方法" class="headerlink" title="process 对象的属性和方法"></a><code>process</code> 对象的属性和方法</h3><p>process对象是一个全局对象，可以在任何地方都能访问到他，通过这个对象提供的属性和方法，使我们可以对当前运行的程序的进程进行访问和控制</p>
<ul>
<li><code>process.argv</code> :一个包含命令行参数的数组。第一个元素会是 ‘node’， 第二个元素将是 .Js 文件的名称。接下来的元素依次是命令行传入的参数。</li>
<li><code>process.execPath</code> : 开启当前进程的绝对路径</li>
<li><code>process.env</code>  : 返回用户环境信息的对象</li>
<li><code>process.version</code>  : 返回node版本信息</li>
<li><code>process.versions</code>  : 返回node以及node依赖包版本信息</li>
<li><code>process.pid</code>  : 当前进程的pid</li>
<li><code>process.title</code>  : 当前进程的显示名称(Getter/Setter)</li>
<li><code>process.arch</code>  : 返回当前CPU处理器架构 arm/ia32/x64</li>
<li><code>process.platform</code>  : 返回当前操作系统平台</li>
<li><code>process.cwd()</code> :  返回当前进程的工作目录</li>
<li><code>process.chdir(directory)</code> :  改变进程的当前进程的工作目录，若操作失败则抛出异常。</li>
<li><code>process.memoryUsage()</code> : 返回node进程的内存使用情况，单位是byte</li>
<li><code>process.exit(code)</code> : 退出</li>
<li><code>process.kill(pid)</code> :  向进程发送信息</li>
<li>标准输入/输出流（IO）：stdin 和stdout提供了操作输入数据和输出数据的方法，我们也通常称为IO操作<ul>
<li><code>stdin</code>：标准输入<a href="http://baike.baidu.com/view/632680.htm" target="_blank" rel="external">http://baike.baidu.com/view/632680.htm</a></li>
<li><code>stdout</code>标准输出<a href="http://baike.baidu.com/view/632676.htm" target="_blank" rel="external">http://baike.baidu.com/view/632676.htm</a></li>
</ul>
</li>
</ul>
<p>这里主要是对于标准输入/输出流（IO）的理解，放上一个中文维基百科的解释：<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E4%B8%B2%E6%B5%81" target="_blank" rel="external">标准输入/输出流</a>，在这里关于 <code>stdout</code>就简单举例 <code>console.log</code>实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">  process.stdout.write(d + <span class="string">'\n'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>再看一个<code>stdin</code>的简单示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.stdout.write(<span class="string">'请输入内容：'</span>);</div><div class="line"><span class="comment">//默认情况下，输入流是关闭的，要监听处理输入流数据，首先要开启输入流</span></div><div class="line">process.stdin.resume();</div><div class="line"><span class="comment">//用于监听用户的输入数据12</span></div><div class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">'用户输入了：'</span> + chunk);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 <code>shell</code> 执行该文件后，输入内容并回车，会把你输入的内容打印出来</p>
<h2 id="Buffer-类"><a href="#Buffer-类" class="headerlink" title="Buffer 类"></a>Buffer 类</h2><p>什么 buffer 类？</p>
<blockquote>
<p>Buffer 类是一个全局变量类型，用于操作二进制数据流的类。我们在操作文件或者网络数据的时候，其实操作的就是二进制数据流，Buffer 类就是 Node 为了我们更好的操 作二进制数据而创建的类</p>
</blockquote>
<ul>
<li><code>new Buffer(size)</code>: Number 类型 配一个新的 buffer 大小是 <code>size</code> 的8位字节.</li>
<li><code>new Buffer(array)</code>: Array 类型分配一个新的 buffer 使用一个8位字节 <code>array</code> 数组.</li>
<li><code>new Buffer(str, [encoding])</code>:分配一个新的 buffer ，其中包含着给定的 <code>str</code> 字符串. <code>encoding</code> 编码方式默认是：<code>&#39;utf8&#39;</code>.<ul>
<li><code>str</code> : String类型 - 需要存入buffer的string字符串.</li>
<li><code>encoding</code> : String类型 - 使用什么编码方式，参数可选.</li>
</ul>
</li>
</ul>
<h3 id="Buffer-方法学习"><a href="#Buffer-方法学习" class="headerlink" title="Buffer 方法学习"></a>Buffer 方法学习</h3><ol>
<li><code>buf.length</code>:这个buffer的bytes大小。注意这未必是这buffer里面内容的大小。length 的依据是buffer对象所分配的内存数值，它不会随着这个buffer对象内容的改变而改变。</li>
<li><code>buf.write(string, [offset], [length], [encoding])</code> : 根据参数 offset 偏移量和指定的encoding编码方式，length 长度是将要写入的字符串的bytes大小，将参数 string 数据写入buffer。<ul>
<li><code>string</code> : String类型 - 将要被写入 buffer 的数据</li>
<li><code>offset</code> : Number类型, 可选参数, 默认: 0</li>
<li><code>length</code> : Number类型, 可选参数, 默认: buffer.length - offset</li>
<li><code>encoding</code> : String类型, 可选参数, 默认: ‘utf8’</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'buffer'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(str));</div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">6</span>);</div><div class="line">buf.write(str,<span class="number">1</span>,<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(buf);</div><div class="line"><span class="comment">// &lt;Buffer 62 75 66 66 65 72&gt;</span></div><div class="line"><span class="comment">// &lt;Buffer 62 62 75 66 01 00&gt;</span></div></pre></td></tr></table></figure>
<p>这里我们指定了 offset 和 length ，分别为1和3，所以可以看到两次在输出时，62，75，66，这部分是相同的，并且第二次输出它的位置偏移了1个位置。</p>
<ol>
<li><code>buf.toString([encoding], [start], [end])</code>：根据 encoding参数（默认是’utf8’）返回一个解码的 string 类型。还会根据传入的参数 start (默认是0)和 end (默认是 buffer.length)作为取值范围。<ul>
<li><code>encoding</code>: String类型, 可选参数, 默认: ‘utf8’</li>
<li><code>start</code>: Number类型, 可选参数, 默认: 0</li>
<li><code>end</code>: Number类型, 可选参数, 默认: buffer.length</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">'buffer'</span>;</div><div class="line"><span class="keyword">var</span> bf1  = <span class="keyword">new</span> Buffer(str1);</div><div class="line"><span class="built_in">console</span>.log(bf1.toString());</div><div class="line"><span class="built_in">console</span>.log(bf1.toString(<span class="string">'utf8'</span>,<span class="number">1</span>,<span class="number">4</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> str2 = <span class="string">'二进制'</span>;</div><div class="line"><span class="keyword">var</span> bf2  = <span class="keyword">new</span> Buffer(str2);</div><div class="line"><span class="built_in">console</span>.log(bf2);</div><div class="line"><span class="built_in">console</span>.log(bf2.toString(<span class="string">'utf8'</span>,<span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">// buffer</span></div><div class="line"><span class="comment">// uff</span></div><div class="line"><span class="comment">// &lt;Buffer e4 ba 8c e8 bf 9b e5 88 b6&gt;</span></div><div class="line"><span class="comment">// ��进制</span></div></pre></td></tr></table></figure>
<p>在这里通过例子和输出，就可以发现 <code>toString()</code> 方法看到在截取时 <strong>取左不取右</strong>，所以第一例子输出了 <code>uff</code>，<br>第二例子则可以说明，中文使用3个字节来存储，所以在偏移量为一时读取到的 <code>ba 8c</code>被输出为乱码，当偏移量为3时，正常。</p>
<ol>
<li><code>buf.toJSON()</code>：返回一个 JSON表示的Buffer实例。JSON.stringify 将会默认调用来字符串序列化这个Buffer实例。如：<code>{ type: &#39;Buffer&#39;, data: [ 98, 117, 102, 102, 101, 114 ] }</code></li>
<li><code>buf.slice([start], [end])</code>:返回一个新的buffer，这个 buffer 将会和老的 buffer 引用相同的内存地址，只是偏移和裁剪了索引，方法类似于数组。 负的索引是从 buffer 尾部开始计算的。</li>
<li><code>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</code>:进行 buffer 的拷贝，源和目标可以是重叠的。 targetStart 目标开始偏移 和sourceStart源开始偏移 默认都是 0. sourceEnd 源结束位置偏移默认是源的长度  buffer.length.<br>如果传递的值是undefined/NaN 或者是 out of bounds 超越边界的，就将设置为他们的默认值。（译者：这个默认值下面有的例子有说明）<ul>
<li><code>targetBuffer</code>: Buffer 类型对象 - 将要进行拷贝的Buffer</li>
<li><code>targetStart</code>: Number类型, 可选参数, 默认: 0</li>
<li><code>sourceStart</code>: Number类型, 可选参数, 默认: 0</li>
<li><code>sourceEnd</code>: Number类型, 可选参数, 默认: buffer.length</li>
</ul>
</li>
</ol>
<h3 id="类-静态方法"><a href="#类-静态方法" class="headerlink" title="类/静态方法"></a>类/静态方法</h3><ol>
<li><code>Buffer.isEncoding(encoding)</code>:用来测试给定的编码字符串,如果给定的编码 encoding 是有效的，返回 true，否则返回 false :<code>Buffer.isEncoding(&#39;utf8&#39;)</code></li>
<li><code>Buffer.isBuffer(obj)</code>:测试这个 obj 是否是一个 Buffer.</li>
<li><code>Buffer.byteLength(string, [encoding])</code>:将会返回这个字符串真实 byte 长度。 encoding 编码默认是： ‘utf8’. 这个和 String.prototype.length 是不一样的，因为那个方法返回这个字符串中有几个字符的数量。</li>
<li><code>Buffer.concat(list, [totalLength])</code>: 返回一个保存着将传入 buffer 数组中所有 buffer 对象拼接在一起的 buffer 对象。其实就是将数组中所有的 buffer 实例通过复制拼接在一起<ul>
<li><code>list</code>: {Array}数组类型，Buffer 数组，用于被连接。</li>
<li><code>totalLength</code>: {Number}类型 上述 Buffer 数组的所有Buffer的总大小。（数组里 Buffer 实例的大小总和）</li>
</ul>
</li>
</ol>
<p>这里我们再回头来看看，在上半部分中的介绍<code>process</code> 对象，说的标准输入输出流的时候，我们有这样一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.stdout.write(<span class="string">'请输入内容：'</span>);</div><div class="line"><span class="comment">//默认情况下，输入流是关闭的，要监听处理输入流数据，首先要开启输入流</span></div><div class="line">process.stdin.resume();</div><div class="line"><span class="comment">//用于监听用户的输入数据12</span></div><div class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">'用户输入了：'</span> + chunk);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们运行这一段代码，在命令行中输入：process，可以看到有下面这样的结果：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入内容：<span class="built_in">process</span></div><div class="line">用户输入了：<span class="built_in">process</span></div></pre></td></tr></table></figure></p>
<p>在这里看来，我们接收到的用户输入 <code>chunk</code> ，就是一个字符串，实际上它是一个buffer对象，我们重写 <code>porcess.stdin</code> 方法，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(chunk);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输入同样的内容打印出来的是 <code>&lt;Buffer 70 72 6f 63 65 73 73 0a&gt;</code> ,可以知道在标准输入输出流中，实际上也是进行二进制的数据传输。<br>在第一个示例中 <code>console.log(&#39;用户输入了：&#39; + chunk);</code> 因为 <code>chunk</code>与字符串相链接，所以 它实际上自动调用了 <code>toString()</code> 方法。</p>
<p>这是对于 process 对象与 Buffer 类的简单学习，理解较为粗浅，如有错误之处请指出，谢谢！</p>
<p>本文地址:<a href="https://guowenfh.github.io/2016/10/15/node-global-object/">https://guowenfh.github.io/2016/10/15/node-global-object/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在上一篇博客中，我们一起对于 node 的模块机制有了一点点的了解，当时我们就知道了在 node 中的全局对象是 &lt;code&gt;global&lt;/code&gt; 而不是浏览器中的 &lt;code&gt;window&lt;/code&gt; 它们有一部分属性方法是相同的，&lt;br
    
    </summary>
    
      <category term="node" scheme="http://guowenfh.github.io/categories/node/"/>
    
    
      <category term="nodejs" scheme="http://guowenfh.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 模块系统</title>
    <link href="http://guowenfh.github.io/2016/10/15/node-module-system/"/>
    <id>http://guowenfh.github.io/2016/10/15/node-module-system/</id>
    <published>2016-10-15T03:18:41.000Z</published>
    <updated>2016-10-15T04:15:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>什么是模块?</p>
</blockquote>
<ul>
<li>在 node 中，文件和模块是一一对应的，也就是一个文件就是一个模块</li>
<li>每个模块都有自己的作用域</li>
<li>我们使用 var 来申明的一个变量，他并不是全局的，而是属于当前模块下</li>
</ul>
<h2 id="模块的加载与使用"><a href="#模块的加载与使用" class="headerlink" title="模块的加载与使用"></a>模块的加载与使用</h2><h3 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h3><p>在 node 中,我们使用 <code>require(&#39;模块&#39;)</code> 的形式将一个模块引入到我们的当前的文件中来。关于 <code>require</code> 路径的写法也有如下几种:</p>
<ul>
<li>模块路径可以是一个以 <code>/</code> 开头，表示一个 <strong>绝对路径</strong></li>
<li>模块路径以 <code>./</code> 开头，表示当前目录出发的 <strong>相对路径</strong></li>
<li>模块路径如果没有以 <code>/</code> 或者 <code>./</code> 开头，那么这个模块要么是 <strong>核心模块</strong> 要么是通过 <strong>npm</strong> 安装在 node_modules 文件夹下的。</li>
</ul>
<p>看到上面的不同路径写法, 我们就想起来在 web 中引入当前文件夹中的文件时是不需要加上<code>./</code>的, 但在 node 中使用 <code>./</code> 或 <code>/</code> 开头的路径和不使用时,有着很大的差别。</p>
<h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><ol>
<li>首先按照加载的模块的文件名称进行查找</li>
<li>如果没有找到，则会在模块文件名称后加上 <code>.js</code> 的后缀，进行查找</li>
<li>如果还没有找到，则会在文件名称后加上 <code>.json</code> 的后缀，进行查找</li>
<li>如果还没有，则会在文件名称后加上 <code>.node</code> 的后缀，进行查找</li>
<li>最终未找到，抛出异常</li>
</ol>
<h3 id="模块数据的使用"><a href="#模块数据的使用" class="headerlink" title="模块数据的使用"></a>模块数据的使用</h3><p>与浏览器中不同 , 在 node 中，每一个模块都有自己的作用域，在模块中使用 var 申明的变量的作用域范围是在该模块内，而不是 node 全局的。<br>但是你忘记了使用 var 进行变量声明,恭喜你这时和浏览器中忘记使用的效果是一致的。该变量也将挂在全局对象上。<br>只不过在 <code>node</code>中，全局对象是<code>global</code>，而不是浏览器中的<code>window</code></p>
<p>下面看一个简单的例子:</p>
<p>我们从两个文件 <code>a.js</code> 和 <code>b.js</code> 就可以简单的看到 node 的声明变量的作用域。</p>
<p>a.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'这是a声明的变量'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'这是a.js模块'</span>);</div></pre></td></tr></table></figure></p>
<p>b.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'./2.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'bbbb'</span>);</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(global.a);</div></pre></td></tr></table></figure></p>
<p><code>node b.js</code> 输出结果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这是<span class="number">2.</span>js模块</div><div class="line">bbbb</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined</span></div></pre></td></tr></table></figure></p>
<p>至于去掉 var 之后会是怎么样,大家自己试试吧 ^ ^</p>
<h2 id="暴露模块API"><a href="#暴露模块API" class="headerlink" title="暴露模块API"></a>暴露模块API</h2><blockquote>
<p>module、module.exports、exports</p>
</blockquote>
<p>如同上面代码中所展示的，在 nodejs 中不能直接去拿到另一个模块中的变量函数等等。要让模块暴露一个API成为 <code>require</code>调用的返回值，我们就需要通过 <code>module.exports</code> 或者 <code>exports</code> 对外提供模块内部变量的访问。</p>
<p>默认情况下，每个模块都会暴露处一个空对象，如果你想要在该对象上添加属性，那么简单的使用 <code>exports</code> 即可。</p>
<p>看这个例子：</p>
<p>module_a.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(exports === <span class="built_in">module</span>.exports)</div><div class="line">exports.name = <span class="string">'module_a.js'</span></div><div class="line">exports.data = <span class="string">'this is module_a.js data'</span></div><div class="line">exports.getDate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>module_b.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./module_a.js'</span>)</div><div class="line"><span class="built_in">console</span>.log(a.name)</div><div class="line"><span class="built_in">console</span>.log(a.data)</div><div class="line"><span class="built_in">console</span>.log(a.getDate())</div></pre></td></tr></table></figure></p>
<p><code>node module_b.js</code>输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span></div><div class="line">module_a.js</div><div class="line">this is module_a.js data</div><div class="line">Thu Sep 22 2016 22:23:59 GMT+0800 (CST)</div></pre></td></tr></table></figure></p>
<p>可以看到这里实际上在模块内部 <code>exports</code> 就是对于<code>module.exports</code>的引用，并且在使用<code>require</code>引入模块之后，a 是一个对象。可见外部模块通过 <code>require(模块)</code> 方法加载模块，该函数返回的就是被加载模块的 <code>module.exports</code> 对象</p>
<p>如果这样在 <code>module.exports</code> 对象上一个一个添加属性还满足不了你的需求，你还可以将 <code>module.exports</code> 彻底重写。我们将上面的两个文件改写：</p>
<p>module_a.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'printf: '</span> + text);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>module_b.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./module_a.js'</span>)</div><div class="line">a(<span class="string">'ok'</span>);</div></pre></td></tr></table></figure></p>
<p><code>node module_b.js</code>输出:<code>printf: ok</code></p>
<p>这样有一个需要注意的地方是：直接覆盖 <code>exports</code> 或者 <code>module.exports</code>让模块导出一个值，这样做会破坏 <code>exports</code> 和  <code>module.exports</code> 的引用关系。</p>
<p>这是对于 node 的模块系统的学习，理解有限，如果有错误之处，请指出，谢谢！</p>
<p>本文地址：<a href="https://guowenfh.github.io/2016/10/15/node-module-system/">https://guowenfh.github.io/2016/10/15/node-module-system/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;什么是模块?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在 node 中，文件和模块是一一对应的，也就是一个文件就是一个模块&lt;/li&gt;
&lt;li&gt;每个模块都有自己的作用域&lt;/li&gt;
&lt;li&gt;我们使用 var 来申明的一个变量，他并不是全局
    
    </summary>
    
      <category term="node" scheme="http://guowenfh.github.io/categories/node/"/>
    
    
      <category term="nodejs" scheme="http://guowenfh.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>eslint 使用实践</title>
    <link href="http://guowenfh.github.io/2016/09/29/eslint-config-npmbace/"/>
    <id>http://guowenfh.github.io/2016/09/29/eslint-config-npmbace/</id>
    <published>2016-09-28T16:32:14.000Z</published>
    <updated>2016-09-28T16:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文地址：<a href="http://guowenfh.github.io/2016/09/29/eslint-config-npmbace/">http://guowenfh.github.io/2016/08/07/eslint-config-npmbace/</a></p>
<blockquote>
<p>在上一篇博客<a href="http://guowenfh.github.io/2016/08/07/ESLint-Rules/">详解 ESLint 规则，规范你的代码</a>中，经过对于 ESLint 规则的学习，当时就决定一定要将 ESLint 使用起来，进行语法校验，来减少我们在程序中可能出现的错误。<br>但在当时，我们仅仅是把 eslint 的规则过了一遍，并没有把 eslint 的使用过程描述出来，而且要真正的在实际中使用，以及想要在团队中推广开来，需要有一个渐渐的过程，所以反响平平，这篇博客十一个补充，我把一些常见的错误和最佳实践集合到了一起（最最基础的）。为了方便大家使用，还将配置作为一个 npm包 来方便大家使用～顺便也学了一下怎怎么发布</p>
</blockquote>
<h3 id="发布一个-eslint-规则的-npm-包"><a href="#发布一个-eslint-规则的-npm-包" class="headerlink" title="发布一个 eslint 规则的 npm 包"></a>发布一个 eslint 规则的 npm 包</h3><p>1.确保本地已经安装node和npm </p>
<p>2.申请npm帐号，直接上官网注册一下就好，在输入下面的命令添加把帐号加到本地之前之前，确保你npm的源地址是官方的地址（我把源切成了淘宝结果在发布包的时候发布不了）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm adduser   </div><div class="line"></div><div class="line">Username: your name</div><div class="line">Password: your password</div><div class="line">Email: yourmail@gmail.com</div></pre></td></tr></table></figure>
<p>3.建立一个存放规则的文件夹，例如我使用的： <code>eslint-config-3introspection</code>（npm包的名称只能小写）<br>按照正常的流程<code>npm init</code>初始化项目，我们把规则存在在一个 <code>eslintrc.js</code>的文件夹中， 因为我们现在的规则实在是太简单，而且也没考虑要真的做为一个开源的项目来维护，我们在index.js只需要写下一句话<code>module.exports = require(&#39;./eslintrc&#39;);</code>，我们的<code>package.json</code>除了name，之外也没做什么修改。。。</p>
<p>（<strong>关于<code>package.json</code>的编写，以及一个最基本的npm包的模样长什么样，我这里不说了，网上很多，也比较简单</strong>）</p>
<p>准备工作都做好了就是发布了，很简单的一个命令：出现错误请自行网上查找把。。。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> publish</div></pre></td></tr></table></figure>
<h3 id="下面简单的说一下使用："><a href="#下面简单的说一下使用：" class="headerlink" title="下面简单的说一下使用："></a>下面简单的说一下使用：</h3><h4 id="第一步：npm-全局安装-eslint-和-eslint-config-3introspection"><a href="#第一步：npm-全局安装-eslint-和-eslint-config-3introspection" class="headerlink" title="第一步：npm 全局安装 eslint 和 eslint-config-3introspection"></a>第一步：npm 全局安装 <code>eslint</code> 和 <code>eslint-config-3introspection</code></h4><p>如果你还没全局安装eslint的话，先执行下面的命令全局安装eslint， 如果已经安装了请看下一条</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install eslint -g</div></pre></td></tr></table></figure>
<p>在全局安装定制的 eslint 包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install eslint-config-3introspection -g</div></pre></td></tr></table></figure>
<p>成功效果如下：<br><img src="http://ww4.sinaimg.cn/large/801b780agw1f89ptaxh5wj20he035aaj.jpg" alt=""></p>
<p>依赖信息的错误不用去管，我们只是需要其中的配置文件而已。</p>
<p>（windows的用户有可能出现无法引入eslint无法引用到全局模块的问题，请将 <code>eslint-config-3introspection</code>，安装在你的工作区目录，以便不同项目都可以引用到）</p>
<h4 id="第二部：在项目的-根目录下-新建一个-eslintrc-文件"><a href="#第二部：在项目的-根目录下-新建一个-eslintrc-文件" class="headerlink" title="第二部：在项目的 根目录下 新建一个 .eslintrc 文件"></a>第二部：在项目的 <strong>根目录</strong>下 新建一个 <code>.eslintrc</code> 文件</h4><p>在文件内部添加下面这样的字段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"extends"</span>: <span class="string">"3introspection"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就将我们定制的规则导入到项目中了。</p>
<h4 id="第三步：检查编辑器是否已经安装-eslint-插件"><a href="#第三步：检查编辑器是否已经安装-eslint-插件" class="headerlink" title="第三步：检查编辑器是否已经安装 eslint 插件"></a>第三步：检查编辑器是否已经安装 eslint 插件</h4><p>下面是sublimeText的：</p>
<p>打开<code>command+shift+p</code>，打开命令窗口，输入 <code>pcl</code> ，回车</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8mN6gw1f7aipmz6m4j30m503k0sx.jpg" alt="pcl"></p>
<p>再输入 <code>sublimeLinter</code>,查看是否如下，不对的话一一安装这两个插件：</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8mN6gw1f7aiqjjsnyj30kv0bdwfh.jpg" alt="sublimeLinter"></p>
<p>若上面两步成功，重启编辑器，再打开文件，应该就能看到 eslint 规则已经生效了，如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8mN6gw1f7aiya10dxj30jt083754.jpg" alt="错误"></p>
<p>这样就可以愉快的使用eslint进行语法校验拉😂😂😂</p>
<p><strong>失败的情况：</strong> 打开<code>command+shift+p</code>，打开命令窗口，输入 <code>sublimeLinter</code> 找到这一项，回车后,找到 eslint 开启选项，重启编辑器再查看是不是已经好了。<br><img src="http://ww1.sinaimg.cn/large/006y8mN6gw1f7aizq6abzj30me0dk75y.jpg" alt="sublimeLinter"></p>
<p>如果规则不不起效果又不知道是什么地方出了问题，参考附录1</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>附录1：vscode<br>安装<br><img src="http://ww2.sinaimg.cn/large/006y8mN6gw1f7aj4ppwzej30cp0g6dgm.jpg" alt=""><br>.eslintrc将<code>{&quot;extends&quot;: &quot;3introspection&quot;}</code>，引入，重启，不起效果的话，vscode会有很明显的报错信息<br><img src="http://ww4.sinaimg.cn/large/801b780agw1f89r0bv5zmj210o027aal.jpg" alt=""><br>还是查找路径的问题，最简单的解决办法，在项目执行一次<code>npm i eslint-config-3introspection</code>，把配置按照到node_modul<br><img src="http://ww4.sinaimg.cn/large/801b780agw1f89qt0mzskj20pd06qjs9.jpg" alt=""><br>其他编辑器都类似</p>
<p>附录2：说明</p>
<ol>
<li>在项目目录中 <code>.eslintrc</code> 中的配置，会覆盖引入的配置，有兴趣的可以进行更详细的定制。例如加入以下字段，将项目的全局变量都列在这边。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 项目中 定义的全局变量</span></div><div class="line"><span class="string">"globals"</span>: &#123;</div><div class="line">    <span class="string">"Tatami"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"$"</span>: <span class="literal">true</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<ol>
<li>在你的 JavaScript 文件中，用注释指定全局变量，格式如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* global var1, var2 */</span></div></pre></td></tr></table></figure>
<ol>
<li>可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：(禁用指定规则，空格后接规则名称，多个名称时逗号隔开)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* eslint-disable */</span></div><div class="line"></div><div class="line">alert(<span class="string">'foo'</span>);<span class="comment">// eslint-disable-line 当前行上禁用所有规则：</span></div><div class="line"></div><div class="line"><span class="comment">/* eslint-enable */</span></div></pre></td></tr></table></figure>
<ol>
<li>快速查看当前模块所有错误，效果如下：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">eslint</span> 模块名/文件名</div></pre></td></tr></table></figure>
<ol>
<li><code>.eslintignore</code>,如同<code>.gitignore</code>一样忽略对于某些文件，文件夹的检查</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/801b780agw1f89rimlemyj211a03p74v.jpg" alt=""></p>
<p>附录3:eslinrc.js 配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="comment">// 环境定义了预定义的全局变量。更多在官网查看</span></div><div class="line">    <span class="string">'env'</span>: &#123;</div><div class="line">        <span class="string">'browser'</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">'node'</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">'commonjs'</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">'amd'</span>: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// JavaScript 语言选项</span></div><div class="line">    <span class="string">'parserOptions'</span>: &#123;</div><div class="line">        <span class="comment">// ECMAScript 版本</span></div><div class="line">        <span class="string">'ecmaVersion'</span>: <span class="number">6</span>,</div><div class="line">        <span class="string">'sourceType'</span>: <span class="string">'script'</span>, <span class="comment">// module</span></div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  "off" 或 0 - 关闭规则</div><div class="line">     *  "warn" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出),</div><div class="line">     *  "error" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</div><div class="line">     */</div><div class="line">    <span class="string">'rules'</span>: &#123;</div><div class="line">        <span class="comment">// //////////////</span></div><div class="line">        <span class="comment">// 可能的错误 //</span></div><div class="line">        <span class="comment">// //////////////</span></div><div class="line">        <span class="string">'no-console'</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止条件表达式中出现赋值操作符</span></div><div class="line">        <span class="string">'no-cond-assign'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在条件中使用常量表达式</span></div><div class="line">        <span class="string">'no-constant-condition'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止 function 定义中出现重名参数</span></div><div class="line">        <span class="string">'no-dupe-args'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对象字面量中出现重复的 key</span></div><div class="line">        <span class="string">'no-dupe-keys'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止重复的 case 标签</span></div><div class="line">        <span class="string">'no-duplicate-case'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止空语句块</span></div><div class="line">        <span class="string">'no-empty'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></div><div class="line">        <span class="string">'no-empty-character-class'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对 catch 子句的参数重新赋值</span></div><div class="line">        <span class="string">'no-ex-assign'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的布尔转换</span></div><div class="line">        <span class="string">'no-extra-boolean-cast'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止对 function 声明重新赋值</span></div><div class="line">        <span class="string">'no-func-assign'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">//  禁止在嵌套的块中出现 function 或 var 声明</span></div><div class="line">        <span class="string">'no-inner-declarations'</span>: [<span class="number">2</span>, <span class="string">'functions'</span>],</div><div class="line">        <span class="comment">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></div><div class="line">        <span class="string">'no-invalid-regexp'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在 in 表达式中出现否定的左操作数</span></div><div class="line">        <span class="string">'no-negated-in-lhs'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// !!!!!!!!!!!禁止出现令人困惑的多行表达式</span></div><div class="line">        <span class="string">'no-unexpected-multiline'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止在return、throw、continue 和 break语句之后出现不可达代码</span></div><div class="line">        <span class="string">'no-unreachable'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 要求使用 isNaN() 检查 NaN</span></div><div class="line">        <span class="string">'use-isnan'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制使用有效的 JSDoc 注释</span></div><div class="line">        <span class="string">'valid-jsdoc'</span>: [<span class="number">1</span>, &#123; <span class="string">'requireReturn'</span>: <span class="literal">false</span> &#125;],</div><div class="line">        <span class="comment">// 强制 typeof 表达式与有效的字符串进行比较</span></div><div class="line">        <span class="comment">// typeof foo === "undefimed" 错误</span></div><div class="line">        <span class="string">'valid-typeof'</span>: <span class="number">2</span>,</div><div class="line"></div><div class="line">        <span class="comment">// ////////////</span></div><div class="line">        <span class="comment">// 最佳实践 //</span></div><div class="line">        <span class="comment">// ////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 强制把变量的使用限制在其定义的作用域范围内</span></div><div class="line">        <span class="string">'block-scoped-var'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 强制所有控制语句使用一致的括号风格</span></div><div class="line">        <span class="string">'curly'</span>: [<span class="number">2</span>, <span class="string">'all'</span>],</div><div class="line">        <span class="comment">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></div><div class="line">        <span class="string">'default-case'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 使用 === 替代 == allow-null允许null和undefined==</span></div><div class="line">        <span class="string">'eqeqeq'</span>: [<span class="number">1</span>, <span class="string">'allow-null'</span>],</div><div class="line">        <span class="comment">// 不允许在 case 子句中使用词法声明</span></div><div class="line">        <span class="string">'no-case-declarations'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></div><div class="line">        <span class="string">'no-div-regex'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></div><div class="line">        <span class="string">'no-eq-null'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止扩展原生类型</span></div><div class="line">        <span class="string">'no-extend-native'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的 .bind() 调用</span></div><div class="line">        <span class="string">'no-extra-bind'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止数字字面量中使用前导和末尾小数点</span></div><div class="line">        <span class="string">'no-floating-decimal'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用不必要的嵌套块</span></div><div class="line">        <span class="string">'no-lone-blocks'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止在循环中出现 function 声明和表达式</span></div><div class="line">        <span class="string">'no-loop-func'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止对原生对象赋值</span></div><div class="line">        <span class="string">'no-native-reassign'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在非赋值或条件语句中使用 new 操作符</span></div><div class="line">        <span class="string">'no-new'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 不允许对 function 的参数进行重新赋值</span></div><div class="line">        <span class="string">'no-param-reassign'</span>: [<span class="number">1</span>, &#123; <span class="string">'props'</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 禁止使用 var 多次声明同一变量</span></div><div class="line">        <span class="string">'no-redeclare'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止自我赋值</span></div><div class="line">        <span class="string">'no-self-assign'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止自身比较</span></div><div class="line">        <span class="string">'no-self-compare'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用一成不变的循环条件</span></div><div class="line">        <span class="string">'no-unmodified-loop-condition'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的 .call() 和 .apply()</span></div><div class="line">        <span class="string">'no-useless-call'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的字符串字面量或模板字面量的连接</span></div><div class="line">        <span class="string">'no-useless-concat'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制在parseInt()使用基数参数</span></div><div class="line">        <span class="string">'radix'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></div><div class="line">        <span class="string">'vars-on-top'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 要求 IIFE 使用括号括起来</span></div><div class="line">        <span class="string">'wrap-iife'</span>: [<span class="number">2</span>, <span class="string">'any'</span>],</div><div class="line"></div><div class="line">        <span class="comment">// ////////////</span></div><div class="line">        <span class="comment">//  变量声明 //</span></div><div class="line">        <span class="comment">// ////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 禁止删除变量</span></div><div class="line">        <span class="string">'no-delete-var'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止 var 声明 与外层作用域的变量同名</span></div><div class="line">        <span class="string">'no-shadow'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止覆盖受限制的标识符</span></div><div class="line">        <span class="string">'no-shadow-restricted-names'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></div><div class="line">        <span class="string">'no-undef'</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止将变量初始化为 undefined</span></div><div class="line">        <span class="string">'no-undef-init'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止将 undefined 作为标识符</span></div><div class="line">        <span class="string">'no-undefined'</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止出现未使用过的变量</span></div><div class="line">        <span class="string">'no-unused-vars'</span>: [<span class="number">1</span>, &#123; <span class="string">'vars'</span>: <span class="string">'all'</span>, <span class="string">'args'</span>: <span class="string">'none'</span> &#125;],</div><div class="line">        <span class="comment">// 不允许在变量定义之前使用它们</span></div><div class="line">        <span class="string">'no-use-before-define'</span>: <span class="number">2</span>,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文地址：&lt;a href=&quot;http://guowenfh.github.io/2016/09/29/eslint-config-npmbace/&quot;&gt;http://guowenfh.github.io/2016/08/07/eslint-config-npmbace/&lt;/a
    
    </summary>
    
      <category term="前端技术" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://guowenfh.github.io/tags/js/"/>
    
      <category term="代码风格" scheme="http://guowenfh.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>详解 ESLint 规则，规范你的代码</title>
    <link href="http://guowenfh.github.io/2016/08/07/ESLint-Rules/"/>
    <id>http://guowenfh.github.io/2016/08/07/ESLint-Rules/</id>
    <published>2016-08-07T02:04:04.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>因为前几天发现 CSDN上有直接把我文章 复制过去然后标原创的情况，以后会统一在博客头部加入原文链接~</p>
<p><a href="http://guowenfh.github.io/2016/08/07/ESLint-Rules/">本文个人博客地址</a></p>
</blockquote>
<p>在很久之前就想通过工具来规范自己的代码风格，减少程序出错的概率，如果看过我的<a href="http://guowenfh.github.io/2015/12/26/SublimeText/">一个前端程序猿的Sublime Text3的自我修养</a>，这篇博客的朋友，肯定知道在当时我使用<code>SublimeLinter-jshint</code>插件来规范风格，但是实际上一直懒癌发作也没去看它的文档，使用着它默认的规则。不过现在是时候切换到 ESLint 了！</p>
<p>作为一个<del>有理想有抱负</del>的前端工程师，只是使用默认规则，而不是看完文档了然于心，显然是不行滴 ^_^.. 团队协作时，若是团队的代码风格统一，能够大大减少沟通成本。（其实面试时和老大聊到代码规范，当时就说到用 JSHint ，或者 ESLint 等工具来统一的。。。这也算是我来填一个坑吧~）</p>
<p>好了，前情摘要就到这，我们开始吧！</p>
<h3 id="什么是-ESLint-？"><a href="#什么是-ESLint-？" class="headerlink" title="什么是 ESLint ？"></a>什么是 ESLint ？</h3><blockquote>
<p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：</p>
<ul>
<li>ESLint 使用 Espree 解析 JavaScript。</li>
<li>ESLint 使用 AST 去分析代码中的模式</li>
<li>ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。</li>
</ul>
</blockquote>
<p>以上来自官网。不想再说下去，反正就是一个代码风格检测工具就对了</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g eslint</div></pre></td></tr></table></figure>
</li>
<li><p>如果你第一次使用 ESLint，你必须使用 –init 命令新建一个配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint --init</div></pre></td></tr></table></figure>
</li>
<li><p>使用 ESLint 检测任何 JavaScript 文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint test.js <span class="built_in">test</span>2.js</div></pre></td></tr></table></figure>
</li>
<li><p>ESLint 中一些规则运行命令它可以帮你自动修复</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint test.js --fix</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了可以更直观的反馈，可能更多的会直接安装编辑器插件来进行错误提示，以Sublime 为例：</p>
<p>在 <code>package control</code> 中 ，先安装在  <code>SublimeLinter</code> ，再安装 <code>SublimeLinter-contrib-eslint</code> 在项目目录下新建 <code>.eslintrc</code> 文件，自定义规则。<br>重新载入文件应该就生效了（不生效的话 <code>Ctrl+Shift+P</code> 调用命令面板 找到<code>sublimelinter: toggle linter</code> 设置生效就好了），其他的编辑器异曲同工，就不再说了。</p>
<p>关于在如何在构建工具中使用，在这里不做说明（官网有）</p>
<h3 id="规则定义"><a href="#规则定义" class="headerlink" title="规则定义"></a>规则定义</h3><p>ESLint 支持几种格式的配置文件，如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p>
<ol>
<li><strong>JavaScript</strong> - 使用 .eslintrc.js 然后输出一个配置对象。</li>
<li><strong>YAML</strong> - 使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。</li>
<li><strong>JSON</strong>  -使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li>
<li><strong>Deprecated</strong>  -使用 .eslintrc，可以使 JSON 也可以是 YAML。</li>
<li><strong>package.json</strong> - 在 package.json 里创建一个 eslintConfig属性，在那里定义你的配置。</li>
</ol>
<p>下面就是规则啦，本人使用了<code>.eslintrc</code>格式，说明也在里面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 环境定义了预定义的全局变量。</span></div><div class="line">    <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="comment">//环境定义了预定义的全局变量。更多在官网查看</span></div><div class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"node"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"commonjs"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"amd"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"es6"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="string">"mocha"</span>:<span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// JavaScript 语言选项</span></div><div class="line">    <span class="string">"parserOptions"</span>: &#123;</div><div class="line">        <span class="comment">// ECMAScript 版本</span></div><div class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">6</span>,</div><div class="line">        <span class="string">"sourceType"</span>: <span class="string">"script"</span>,<span class="comment">//module</span></div><div class="line">        <span class="comment">// 想使用的额外的语言特性:</span></div><div class="line">        <span class="string">"ecmaFeatures"</span>: &#123;</div><div class="line">            <span class="comment">// 允许在全局作用域下使用 return 语句</span></div><div class="line">            <span class="string">"globalReturn"</span>:<span class="literal">true</span>,</div><div class="line">            <span class="comment">// impliedStric</span></div><div class="line">            <span class="string">"impliedStrict"</span>:<span class="literal">true</span>,</div><div class="line">            <span class="comment">// 启用 JSX</span></div><div class="line">            <span class="string">"jsx"</span>:<span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  "off" 或 0 - 关闭规则</div><div class="line">     *  "warn" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出),</div><div class="line">     *  "error" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</div><div class="line">     */</div><div class="line">    <span class="string">"rules"</span>: &#123;</div><div class="line"></div><div class="line">        <span class="comment">////////////////</span></div><div class="line">        <span class="comment">// 可能的错误  //</span></div><div class="line">        <span class="comment">////////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 禁止条件表达式中出现赋值操作符</span></div><div class="line">        <span class="string">"no-cond-assign"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用 console</span></div><div class="line">        <span class="string">"no-console"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止在条件中使用常量表达式</span></div><div class="line">        <span class="comment">// if (false) &#123;</span></div><div class="line">        <span class="comment">//     doSomethingUnfinished();</span></div><div class="line">        <span class="comment">// &#125; //cuowu</span></div><div class="line">        <span class="string">"no-constant-condition"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f")</span></div><div class="line">        <span class="string">"no-control-regex"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span></div><div class="line">        <span class="comment">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></div><div class="line">        <span class="string">"comma-dangle"</span>: [<span class="number">1</span>, <span class="string">"always-multiline"</span>],</div><div class="line">        <span class="comment">// 禁用 debugger</span></div><div class="line">        <span class="string">"no-debugger"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止 function 定义中出现重名参数</span></div><div class="line">        <span class="string">"no-dupe-args"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对象字面量中出现重复的 key</span></div><div class="line">        <span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止重复的 case 标签</span></div><div class="line">        <span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止空语句块</span></div><div class="line">        <span class="string">"no-empty"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></div><div class="line">        <span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对 catch 子句的参数重新赋值</span></div><div class="line">        <span class="string">"no-ex-assign"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的布尔转换</span></div><div class="line">        <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">//  禁止不必要的括号 //(a * b) + c;//报错</span></div><div class="line">        <span class="string">"no-extra-parens"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止不必要的分号</span></div><div class="line">        <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对 function 声明重新赋值</span></div><div class="line">        <span class="string">"no-func-assign"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">//  禁止在嵌套的块中出现 function 或 var 声明</span></div><div class="line">        <span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],</div><div class="line">        <span class="comment">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></div><div class="line">        <span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在字符串和注释之外不规则的空白</span></div><div class="line">        <span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在 in 表达式中出现否定的左操作数</span></div><div class="line">        <span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">//   禁止把全局对象 (Math 和 JSON) 作为函数调用  错误：var math = Math();</span></div><div class="line">        <span class="string">"no-obj-calls"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止直接使用 Object.prototypes 的内置属性</span></div><div class="line">        <span class="string">"no-prototype-builtins"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止正则表达式字面量中出现多个空格</span></div><div class="line">        <span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用稀疏数组</span></div><div class="line">        <span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止出现令人困惑的多行表达式</span></div><div class="line">        <span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在return、throw、continue 和 break语句之后出现不可达代码</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">            function foo() &#123;</div><div class="line">            return true;</div><div class="line">            console.log("done");</div><div class="line">            &#125;//错误</div><div class="line">        */</div><div class="line">        <span class="string">"no-unreachable"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 要求使用 isNaN() 检查 NaN</span></div><div class="line">        <span class="string">"use-isnan"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制使用有效的 JSDoc 注释</span></div><div class="line">        <span class="string">"valid-jsdoc"</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 强制 typeof 表达式与有效的字符串进行比较</span></div><div class="line">        <span class="comment">// typeof foo === "undefimed" 错误</span></div><div class="line">        <span class="string">"valid-typeof"</span>: <span class="number">2</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//////////////</span></div><div class="line">        <span class="comment">// 最佳实践 //</span></div><div class="line">        <span class="comment">//////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 定义对象的set存取器属性时，强制定义get</span></div><div class="line">        <span class="string">"accessor-pairs"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制数组方法的回调函数中有 return 语句</span></div><div class="line">        <span class="string">"array-callback-return"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制把变量的使用限制在其定义的作用域范围内</span></div><div class="line">        <span class="string">"block-scoped-var"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 限制圈复杂度，也就是类似if else能连续接多少个</span></div><div class="line">        <span class="string">"complexity"</span>: [<span class="number">2</span>, <span class="number">9</span>],</div><div class="line">        <span class="comment">//  要求 return 语句要么总是指定返回的值，要么不指定</span></div><div class="line">        <span class="string">"consistent-return"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制所有控制语句使用一致的括号风格</span></div><div class="line">        <span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],</div><div class="line">        <span class="comment">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></div><div class="line">        <span class="string">"default-case"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制object.key 中 . 的位置，参数:</span></div><div class="line">        <span class="comment">//      property，'.'号应与属性在同一行</span></div><div class="line">        <span class="comment">//      object, '.' 号应与对象名在同一行</span></div><div class="line">        <span class="string">"dot-location"</span>: [<span class="number">2</span>, <span class="string">"property"</span>],</div><div class="line">        <span class="comment">// 强制使用.号取属性</span></div><div class="line">        <span class="comment">//    参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性</span></div><div class="line">        <span class="comment">//                          false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;"allowKeywords": false&#125;]</span></div><div class="line">        <span class="comment">//           allowPattern:  当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;]</span></div><div class="line">        <span class="string">"dot-notation"</span>: [<span class="number">2</span>, &#123; <span class="string">"allowKeywords"</span>: <span class="literal">false</span> &#125;],</div><div class="line">        <span class="comment">// 使用 === 替代 == allow-null允许null和undefined==</span></div><div class="line">        <span class="string">"eqeqeq"</span>: [<span class="number">2</span>, <span class="string">"allow-null"</span>],</div><div class="line">        <span class="comment">// 要求 for-in 循环中有一个 if 语句</span></div><div class="line">        <span class="string">"guard-for-in"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用 alert、confirm 和 prompt</span></div><div class="line">        <span class="string">"no-alert"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 arguments.caller 或 arguments.callee</span></div><div class="line">        <span class="string">"no-caller"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许在 case 子句中使用词法声明</span></div><div class="line">        <span class="string">"no-case-declarations"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></div><div class="line">        <span class="string">"no-div-regex"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止 if 语句中有 return 之后有 else</span></div><div class="line">        <span class="string">"no-else-return"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</span></div><div class="line">        <span class="string">"no-empty-function"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止使用空解构模式no-empty-pattern</span></div><div class="line">        <span class="string">"no-empty-pattern"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></div><div class="line">        <span class="string">"no-eq-null"</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁用 eval()</span></div><div class="line">        <span class="string">"no-eval"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止扩展原生类型</span></div><div class="line">        <span class="string">"no-extend-native"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的 .bind() 调用</span></div><div class="line">        <span class="string">"no-extra-bind"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用不必要的标签</span></div><div class="line">        <span class="string">"no-extra-label:"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止 case 语句落空</span></div><div class="line">        <span class="string">"no-fallthrough"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止数字字面量中使用前导和末尾小数点</span></div><div class="line">        <span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止使用短符号进行类型转换(!!fOO)</span></div><div class="line">        <span class="string">"no-implicit-coercion"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止在全局范围内使用 var 和命名的 function 声明</span></div><div class="line">        <span class="string">"no-implicit-globals"</span>:<span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁止使用类似 eval() 的方法</span></div><div class="line">        <span class="string">"no-implied-eval"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止 this 关键字出现在类和类对象之外</span></div><div class="line">        <span class="string">"no-invalid-this"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 __iterator__ 属性</span></div><div class="line">        <span class="string">"no-iterator"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">//  禁用标签语句</span></div><div class="line">        <span class="string">"no-labels"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用不必要的嵌套块</span></div><div class="line">        <span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在循环中出现 function 声明和表达式</span></div><div class="line">        <span class="string">"no-loop-func"</span>:<span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁用魔术数字(3.14什么的用常量代替)</span></div><div class="line">        <span class="string">"no-magic-numbers"</span>:[<span class="number">1</span>,&#123; <span class="string">"ignore"</span>: [<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>] &#125;],</div><div class="line">        <span class="comment">// 禁止使用多个空格</span></div><div class="line">        <span class="string">"no-multi-spaces"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></div><div class="line">        <span class="string">"no-multi-str"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对原生对象赋值</span></div><div class="line">        <span class="string">"no-native-reassign"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在非赋值或条件语句中使用 new 操作符</span></div><div class="line">        <span class="string">"no-new"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对 Function 对象使用 new 操作符</span></div><div class="line">        <span class="string">"no-new-func"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></div><div class="line">        <span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用八进制字面量</span></div><div class="line">        <span class="string">"no-octal"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止在字符串中使用八进制转义序列</span></div><div class="line">        <span class="string">"no-octal-escape"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许对 function 的参数进行重新赋值</span></div><div class="line">        <span class="string">"no-param-reassign"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 __proto__ 属性</span></div><div class="line">        <span class="string">"no-proto"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止使用 var 多次声明同一变量</span></div><div class="line">        <span class="string">"no-redeclare"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用指定的通过 require 加载的模块</span></div><div class="line">        <span class="string">"no-return-assign"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止使用 javascript: url</span></div><div class="line">        <span class="string">"no-script-url"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止自我赋值</span></div><div class="line">        <span class="string">"no-self-assign"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止自身比较</span></div><div class="line">        <span class="string">"no-self-compare"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用逗号操作符</span></div><div class="line">        <span class="string">"no-sequences"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止抛出非异常字面量</span></div><div class="line">        <span class="string">"no-throw-literal"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用一成不变的循环条件</span></div><div class="line">        <span class="string">"no-unmodified-loop-condition"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止出现未使用过的表达式</span></div><div class="line">        <span class="string">"no-unused-expressions"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用未使用过的标签</span></div><div class="line">        <span class="string">"no-unused-labels"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的 .call() 和 .apply()</span></div><div class="line">        <span class="string">"no-useless-call"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的字符串字面量或模板字面量的连接</span></div><div class="line">        <span class="string">"no-useless-concat"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用不必要的转义字符</span></div><div class="line">        <span class="string">"no-useless-escape"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 void 操作符</span></div><div class="line">        <span class="string">"no-void"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止在注释中使用特定的警告术语</span></div><div class="line">        <span class="string">"no-warning-comments"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 with 语句</span></div><div class="line">        <span class="string">"no-with"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制在parseInt()使用基数参数</span></div><div class="line">        <span class="string">"radix"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></div><div class="line">        <span class="string">"vars-on-top"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求 IIFE 使用括号括起来</span></div><div class="line">        <span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"any"</span>],</div><div class="line">        <span class="comment">// 要求或禁止 “Yoda” 条件</span></div><div class="line">        <span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</div><div class="line">        <span class="comment">// 要求或禁止使用严格模式指令</span></div><div class="line">        <span class="string">"strict"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//////////////</span></div><div class="line">        <span class="comment">//  变量声明 //</span></div><div class="line">        <span class="comment">//////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 要求或禁止 var 声明中的初始化(初值)</span></div><div class="line">        <span class="string">"init-declarations"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></div><div class="line">        <span class="string">"no-catch-shadow"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止删除变量</span></div><div class="line">        <span class="string">"no-delete-var"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许标签与变量同名</span></div><div class="line">        <span class="string">"no-label-var"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用特定的全局变量</span></div><div class="line">        <span class="string">"no-restricted-globals"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止 var 声明 与外层作用域的变量同名</span></div><div class="line">        <span class="string">"no-shadow"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止覆盖受限制的标识符</span></div><div class="line">        <span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></div><div class="line">        <span class="string">"no-undef"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止将变量初始化为 undefined</span></div><div class="line">        <span class="string">"no-undef-init"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止将 undefined 作为标识符</span></div><div class="line">        <span class="string">"no-undefined"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止出现未使用过的变量</span></div><div class="line">        <span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123; <span class="string">"vars"</span>: <span class="string">"all"</span>, <span class="string">"args"</span>: <span class="string">"none"</span> &#125;],</div><div class="line">        <span class="comment">// 不允许在变量定义之前使用它们</span></div><div class="line">        <span class="string">"no-use-before-define"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line">        <span class="comment">//////////////////////////</span></div><div class="line">        <span class="comment">// Node.js and CommonJS //</span></div><div class="line">        <span class="comment">//////////////////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// require return statements after callbacks</span></div><div class="line">        <span class="string">"callback-return"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求 require() 出现在顶层模块作用域中</span></div><div class="line">        <span class="string">"global-require"</span>: <span class="number">1</span>,</div><div class="line">        <span class="comment">// 要求回调函数中有容错处理</span></div><div class="line">        <span class="string">"handle-callback-err"</span>: [<span class="number">2</span>, <span class="string">"^(err|error)$"</span>],</div><div class="line">        <span class="comment">// 禁止混合常规 var 声明和 require 调用</span></div><div class="line">        <span class="string">"no-mixed-requires"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止调用 require 时使用 new 操作符</span></div><div class="line">        <span class="string">"no-new-require"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止对 __dirname 和 __filename进行字符串连接</span></div><div class="line">        <span class="string">"no-path-concat"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 process.env</span></div><div class="line">        <span class="string">"no-process-env"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用 process.exit()</span></div><div class="line">        <span class="string">"no-process-exit"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁用同步方法</span></div><div class="line">        <span class="string">"no-sync"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line">        <span class="comment">//////////////</span></div><div class="line">        <span class="comment">// 风格指南  //</span></div><div class="line">        <span class="comment">//////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span></div><div class="line">        <span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</div><div class="line">        <span class="comment">// 禁止或强制在单行代码块中使用空格(禁用)</span></div><div class="line">        <span class="string">"block-spacing"</span>:[<span class="number">1</span>,<span class="string">"never"</span>],</div><div class="line">        <span class="comment">//强制使用一致的缩进 第二个参数为 "tab" 时，会使用tab，</span></div><div class="line">        <span class="comment">// if while function 后面的&#123;必须与if在同一行，java风格。</span></div><div class="line">        <span class="string">"brace-style"</span>: [<span class="number">2</span>, <span class="string">"1tbs"</span>, &#123; <span class="string">"allowSingleLine"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 双峰驼命名格式</span></div><div class="line">        <span class="string">"camelcase"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 控制逗号前后的空格</span></div><div class="line">        <span class="string">"comma-spacing"</span>: [<span class="number">2</span>, &#123; <span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></div><div class="line">        <span class="comment">// http://eslint.org/docs/rules/comma-style</span></div><div class="line">        <span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],</div><div class="line">        <span class="comment">//"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></div><div class="line">        <span class="comment">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span></div><div class="line">        <span class="string">"computed-property-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</div><div class="line">        <span class="comment">// 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</span></div><div class="line">        <span class="comment">// e.g [0,"that"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值</span></div><div class="line">        <span class="string">"consistent-this"</span>:  [<span class="number">1</span>,<span class="string">"that"</span>],</div><div class="line">        <span class="comment">// 强制使用命名的 function 表达式</span></div><div class="line">        <span class="string">"func-names"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 文件末尾强制换行</span></div><div class="line">        <span class="string">"eol-last"</span>: <span class="number">2</span>,</div><div class="line">        <span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">4</span>, &#123; <span class="string">"SwitchCase"</span>: <span class="number">1</span> &#125;],</div><div class="line">        <span class="comment">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></div><div class="line">        <span class="string">"key-spacing"</span>: [<span class="number">2</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span>, <span class="string">"afterColon"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 强制使用一致的换行风格</span></div><div class="line">        <span class="string">"linebreak-style"</span>: [<span class="number">1</span>,<span class="string">"unix"</span>],</div><div class="line">        <span class="comment">// 要求在注释周围有空行      ( 要求在块级注释之前有一空行)</span></div><div class="line">        <span class="string">"lines-around-comment"</span>: [<span class="number">1</span>,&#123;<span class="string">"beforeBlockComment"</span>:<span class="literal">true</span>&#125;],</div><div class="line">        <span class="comment">//  强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></div><div class="line">        <span class="comment">//    declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"]</span></div><div class="line">        <span class="comment">//    expression：强制使用方法表达式的方式，var f = function() &#123;&#125;  e.g [2, "expression"]</span></div><div class="line">        <span class="comment">//    allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, "declaration", &#123; "allowArrowFunctions": true &#125;]</span></div><div class="line">        <span class="string">"func-style"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制回调函数最大嵌套深度 5层</span></div><div class="line">        <span class="string">"max-nested-callbacks"</span>: [<span class="number">1</span>,<span class="number">5</span>],</div><div class="line">        <span class="comment">// 禁止使用指定的标识符</span></div><div class="line">        <span class="string">"id-blacklist"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制标识符的最新和最大长度</span></div><div class="line">        <span class="string">"id-length"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求标识符匹配一个指定的正则表达式</span></div><div class="line">        <span class="string">"id-match"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制在 JSX 属性中一致地使用双引号或单引号</span></div><div class="line">        <span class="string">"jsx-quotes"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></div><div class="line">        <span class="string">"keyword-spacing"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制一行的最大长度</span></div><div class="line">        <span class="string">"max-len"</span>:[<span class="number">1</span>,<span class="number">200</span>],</div><div class="line">        <span class="comment">// 强制最大行数</span></div><div class="line">        <span class="string">"max-lines"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制 function 定义中最多允许的参数数量</span></div><div class="line">        <span class="string">"max-params"</span>:[<span class="number">1</span>,<span class="number">7</span>],</div><div class="line">        <span class="comment">// 强制 function 块最多允许的的语句数量</span></div><div class="line">        <span class="string">"max-statements"</span>:[<span class="number">1</span>,<span class="number">200</span>],</div><div class="line">        <span class="comment">// 强制每一行中所允许的最大语句数量</span></div><div class="line">        <span class="string">"max-statements-per-line"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求构造函数首字母大写  （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></div><div class="line">        <span class="string">"new-cap"</span>: [<span class="number">2</span>, &#123; <span class="string">"newIsCap"</span>: <span class="literal">true</span>, <span class="string">"capIsNew"</span>: <span class="literal">false</span> &#125;],</div><div class="line">        <span class="comment">// 要求调用无参构造函数时有圆括号</span></div><div class="line">        <span class="string">"new-parens"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 要求或禁止 var 声明语句后有一行空行</span></div><div class="line">        <span class="string">"newline-after-var"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止使用 Array 构造函数</span></div><div class="line">        <span class="string">"no-array-constructor"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁用按位运算符</span></div><div class="line">        <span class="string">"no-bitwise"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求 return 语句之前有一空行</span></div><div class="line">        <span class="string">"newline-before-return"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求方法链中每个调用都有一个换行符</span></div><div class="line">        <span class="string">"newline-per-chained-call"</span>:<span class="number">1</span>,</div><div class="line">        <span class="comment">// 禁用 continue 语句</span></div><div class="line">        <span class="string">"no-continue"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止在代码行后使用内联注释</span></div><div class="line">        <span class="string">"no-inline-comments"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止 if 作为唯一的语句出现在 else 语句中</span></div><div class="line">        <span class="string">"no-lonely-if"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止混合使用不同的操作符</span></div><div class="line">        <span class="string">"no-mixed-operators"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 不允许空格和 tab 混合缩进</span></div><div class="line">        <span class="string">"no-mixed-spaces-and-tabs"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许多个空行</span></div><div class="line">        <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123; <span class="string">"max"</span>: <span class="number">2</span> &#125;],</div><div class="line">        <span class="comment">// 不允许否定的表达式</span></div><div class="line">        <span class="string">"no-negated-condition"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 不允许使用嵌套的三元表达式</span></div><div class="line">        <span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止使用 Object 的构造函数</span></div><div class="line">        <span class="string">"no-new-object"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止使用一元操作符 ++ 和 --</span></div><div class="line">        <span class="string">"no-plusplus"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止使用特定的语法</span></div><div class="line">        <span class="string">"no-restricted-syntax"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止 function 标识符和括号之间出现空格</span></div><div class="line">        <span class="string">"no-spaced-func"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许使用三元操作符</span></div><div class="line">        <span class="string">"no-ternary"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">//  禁用行尾空格</span></div><div class="line">        <span class="string">"no-trailing-spaces"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止标识符中有悬空下划线_bar</span></div><div class="line">        <span class="string">"no-underscore-dangle"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></div><div class="line">        <span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止属性前有空白</span></div><div class="line">        <span class="string">"no-whitespace-before-property"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制花括号内换行符的一致性</span></div><div class="line">        <span class="string">"object-curly-newline"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制在花括号中使用一致的空格</span></div><div class="line">        <span class="string">"object-curly-spacing"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制将对象的属性放在不同的行上</span></div><div class="line">        <span class="string">"object-property-newline"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制函数中的变量要么一起声明要么分开声明</span></div><div class="line">        <span class="string">"one-var"</span>: [<span class="number">2</span>, &#123; <span class="string">"initialized"</span>: <span class="string">"never"</span> &#125;],</div><div class="line">        <span class="comment">// 要求或禁止在 var 声明周围换行</span></div><div class="line">        <span class="string">"one-var-declaration-per-line"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></div><div class="line">        <span class="string">"operator-assignment"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制操作符使用一致的换行符</span></div><div class="line">        <span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>, &#123; <span class="string">"overrides"</span>: &#123; <span class="string">"?"</span>: <span class="string">"before"</span>, <span class="string">":"</span>: <span class="string">"before"</span> &#125; &#125;],</div><div class="line">        <span class="comment">// 要求或禁止块内填充</span></div><div class="line">        <span class="string">"padded-blocks"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求对象字面量属性名称用引号括起来</span></div><div class="line">        <span class="string">"quote-props"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制使用一致的反勾号、双引号或单引号</span></div><div class="line">        <span class="string">"quotes"</span>: [<span class="number">2</span>, <span class="string">"single"</span>, <span class="string">"avoid-escape"</span>],</div><div class="line">        <span class="comment">// 要求使用 JSDoc 注释</span></div><div class="line">        <span class="string">"require-jsdoc"</span>:<span class="number">1</span>,</div><div class="line">        <span class="comment">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></div><div class="line">        <span class="string">"semi"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],</div><div class="line">        <span class="comment">// 强制分号之前和之后使用一致的空格</span></div><div class="line">        <span class="string">"semi-spacing"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求同一个声明块中的变量按顺序排列</span></div><div class="line">        <span class="string">"sort-vars"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制在块之前使用一致的空格</span></div><div class="line">        <span class="string">"space-before-blocks"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],</div><div class="line">        <span class="comment">// 强制在 function的左括号之前使用一致的空格</span></div><div class="line">        <span class="string">"space-before-function-paren"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],</div><div class="line">        <span class="comment">// 强制在圆括号内使用一致的空格</span></div><div class="line">        <span class="string">"space-in-parens"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</div><div class="line">        <span class="comment">// 要求操作符周围有空格</span></div><div class="line">        <span class="string">"space-infix-ops"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 强制在一元操作符前后使用一致的空格</span></div><div class="line">        <span class="string">"space-unary-ops"</span>: [<span class="number">2</span>, &#123; <span class="string">"words"</span>: <span class="literal">true</span>, <span class="string">"nonwords"</span>: <span class="literal">false</span> &#125;],</div><div class="line">        <span class="comment">// 强制在注释中 // 或 /* 使用一致的空格</span></div><div class="line">        <span class="string">"spaced-comment"</span>: [<span class="number">2</span>, <span class="string">"always"</span>, &#123; <span class="string">"markers"</span>: [<span class="string">"global"</span>, <span class="string">"globals"</span>, <span class="string">"eslint"</span>, <span class="string">"eslint-disable"</span>, <span class="string">"*package"</span>, <span class="string">"!"</span>] &#125;],</div><div class="line">        <span class="comment">// 要求或禁止 Unicode BOM</span></div><div class="line">        <span class="string">"unicode-bom"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">//  要求正则表达式被括号括起来</span></div><div class="line">        <span class="string">"wrap-regex"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line">        <span class="comment">//////////////</span></div><div class="line">        <span class="comment">// ES6.相关 //</span></div><div class="line">        <span class="comment">//////////////</span></div><div class="line"></div><div class="line">        <span class="comment">// 要求箭头函数体使用大括号</span></div><div class="line">        <span class="string">"arrow-body-style"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 要求箭头函数的参数使用圆括号</span></div><div class="line">        <span class="string">"arrow-parens"</span>: <span class="number">2</span>,</div><div class="line">        <span class="string">"arrow-spacing"</span>:[<span class="number">2</span>,&#123; <span class="string">"before"</span>: <span class="literal">true</span>, <span class="string">"after"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</span></div><div class="line">        <span class="string">"constructor-super"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制 generator 函数中 * 号周围使用一致的空格</span></div><div class="line">        <span class="string">"generator-star-spacing"</span>: [<span class="number">2</span>, &#123; <span class="string">"before"</span>: <span class="literal">true</span>, <span class="string">"after"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="comment">// 禁止修改类声明的变量</span></div><div class="line">        <span class="string">"no-class-assign"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许箭头功能，在那里他们可以混淆的比较</span></div><div class="line">        <span class="string">"no-confusing-arrow"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止修改 const 声明的变量</span></div><div class="line">        <span class="string">"no-const-assign"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止类成员中出现重复的名称</span></div><div class="line">        <span class="string">"no-dupe-class-members"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 不允许复制模块的进口</span></div><div class="line">        <span class="string">"no-duplicate-imports"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止 Symbol  的构造函数</span></div><div class="line">        <span class="string">"no-new-symbol"</span>:<span class="number">2</span>,</div><div class="line">        <span class="comment">// 允许指定模块加载时的进口</span></div><div class="line">        <span class="string">"no-restricted-imports"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></div><div class="line">        <span class="string">"no-this-before-super"</span>: <span class="number">2</span>,</div><div class="line">        <span class="comment">// 禁止不必要的计算性能键对象的文字</span></div><div class="line">        <span class="string">"no-useless-computed-key"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求使用 let 或 const 而不是 var</span></div><div class="line">        <span class="string">"no-var"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求或禁止对象字面量中方法和属性使用简写语法</span></div><div class="line">        <span class="string">"object-shorthand"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求使用箭头函数作为回调</span></div><div class="line">        <span class="string">"prefer-arrow-callback"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求使用 const 声明那些声明后不再被修改的变量</span></div><div class="line">        <span class="string">"prefer-const"</span>: <span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求在合适的地方使用 Reflect 方法</span></div><div class="line">        <span class="string">"prefer-reflect"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求使用扩展运算符而非 .apply()</span></div><div class="line">        <span class="string">"prefer-spread"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求使用模板字面量而非字符串连接</span></div><div class="line">        <span class="string">"prefer-template"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// Suggest using the rest parameters instead of arguments</span></div><div class="line">        <span class="string">"prefer-rest-params"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求generator 函数内有 yield</span></div><div class="line">        <span class="string">"require-yield"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// enforce spacing between rest and spread operators and their expressions</span></div><div class="line">        <span class="string">"rest-spread-spacing"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 强制模块内的 import 排序</span></div><div class="line">        <span class="string">"sort-imports"</span>:<span class="number">0</span>,</div><div class="line">        <span class="comment">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></div><div class="line">        <span class="string">"template-curly-spacing"</span>:<span class="number">1</span>,</div><div class="line">        <span class="comment">// 强制在 yield* 表达式中 * 周围使用空格</span></div><div class="line">        <span class="string">"yield-star-spacing"</span>:<span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多内容，以及每一项的配置详情可以在 <a href="http://eslint.cn/" target="_blank" rel="external">官网查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为前几天发现 CSDN上有直接把我文章 复制过去然后标原创的情况，以后会统一在博客头部加入原文链接~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://guowenfh.github.io/2016/08/07/ESLint-Rules/&quot;&gt;本文个人
    
    </summary>
    
      <category term="前端技术" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://guowenfh.github.io/tags/js/"/>
    
      <category term="代码风格" scheme="http://guowenfh.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中this与闭包学习笔记</title>
    <link href="http://guowenfh.github.io/2016/08/03/javascript-this-closure/"/>
    <id>http://guowenfh.github.io/2016/08/03/javascript-this-closure/</id>
    <published>2016-08-02T16:30:29.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解-Javascript中的this"><a href="#理解-Javascript中的this" class="headerlink" title="理解 Javascript中的this"></a>理解 <code>Javascript</code>中的<code>this</code></h3><p>基于不同的调用方式this的指向也会有所不同，调用方式大致有如下几种：</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造函数调用</td>
<td><code>new Foo();</code></td>
</tr>
<tr>
<td>对象方法调用</td>
<td><code>o.method();</code></td>
</tr>
<tr>
<td>函数直接调用</td>
<td><code>foo();</code></td>
</tr>
<tr>
<td>call/apply/bind</td>
<td><code>func.call(o);</code></td>
</tr>
</tbody>
</table>
<p>现在就来看看这些不同的调用模式，this的指向会有怎么样的区别：</p>
<h4 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayName  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> allen = <span class="keyword">new</span> Person(<span class="string">"allen"</span>,<span class="number">12</span>);</div><div class="line"><span class="built_in">console</span>.info(allen);<span class="comment">//&#123;name: "allen", age: 12&#125;;...</span></div></pre></td></tr></table></figure>
<p>通过这样的代码可以很清楚的的看出，构造函数 Person 内部的<code>this</code>指向被创建的调用对象 allen</p>
<h4 id="对象方法调用"><a href="#对象方法调用" class="headerlink" title="对象方法调用"></a>对象方法调用</h4><p>通过上面的代码很明显我们创建了一个 allen 对象，其中有一个 <code>sayName</code> 方法, 直接打印 this.name ，现在我们就来看一下它会输出什么。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">allen.sayName();<span class="comment">//allen</span></div></pre></td></tr></table></figure></p>
<p>很明显，这里函数中的<code>this</code>指向<code>allen</code>对象本身。</p>
<h4 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h4><p>先来看一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myNumber = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">double</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = add(<span class="keyword">this</span>.value, <span class="keyword">this</span>.value);</div><div class="line">        &#125;</div><div class="line">        handle();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.info(myNumber.value);<span class="comment">//1</span></div><div class="line">myNumber.double();</div><div class="line"><span class="built_in">console</span>.info(myNumber.value);<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>解析： 首先我们定义了一个全局函数<code>add</code>用于加法运算，接着我们定义了一个对象，有一属性value为1，还有一个方法的目的是让value值乘以二。我们在函数内嵌套定义了一个函数<code>handle</code>,调用<code>add</code>方法并且执行。但是在调用函数值执行之后并没有达到我们想要的效果。这是为什么呢？<br>如何你打开chrome调试工具并打下断点会发现在<code>handle</code>函数内部的this会指向window！<br>由此可以发现，<strong>在函数内部创建的函数，在这个函数调用时，函数内部的<code>this</code>会指向window而不是外部的函数</strong></p>
<p>下面就就可以看一下常见的两个方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取消 handle函数的定义，直接在对象的方法中使用this</span></div><div class="line">double2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = add(<span class="keyword">this</span>.value, <span class="keyword">this</span>.value);</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 使用变量保存外部函数的this。</span></div><div class="line">double3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        that.value = add(that.value, that.value);</div><div class="line">    &#125;</div><div class="line">    handle();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-call-apply与bind-手动改变-this"><a href="#使用-call-apply与bind-手动改变-this" class="headerlink" title="使用 call/apply与bind 手动改变 this"></a>使用 <code>call</code>/<code>apply</code>与<code>bind</code> 手动改变 this</h4><p>先来看下面这样一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line">Point.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">stepX, stepY</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.x += stepX;</div><div class="line">    <span class="keyword">this</span>.y += stepY;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(p);<span class="comment">//&#123;x: 0, y: 0&#125;</span></div><div class="line">p.move(<span class="number">2</span>,<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(p);<span class="comment">//&#123;x: 2, y: 2&#125;</span></div><div class="line"><span class="keyword">var</span> circle = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>,<span class="attr">r</span>:<span class="number">1</span>&#125;;</div><div class="line">p.move.apply(circle, [<span class="number">2</span>,<span class="number">1</span>]);</div><div class="line"><span class="built_in">console</span>.info(circle);<span class="comment">//&#123;x: 3, y: 2, r: 1&#125;</span></div></pre></td></tr></table></figure></p>
<p>我们使用<code>Point</code>构造函数可以创建出一个点，在其原型上有一个<code>move</code>方法可以使这个点坐标移动。<br>之后我们又创建<code>circle</code>对象，有x/y/r属性（把它想象成一个圆），之后我们的需求是：将这个圆的圆心移动，我们就使用了<code>apply</code>来借用<code>move</code>方法，最终将圆移动了位置，最终效果如下图：<br><img src="http://ww4.sinaimg.cn/large/82d12951gw1f6emf8rigdj208l07tglm.jpg" alt="apply使用圆示意图"></p>
<ul>
<li><code>function.prototype.apply/call</code></li>
</ul>
<p>在上面我们可以看到能实现圆心移动的关键方法就是<code>apply</code>，大致解析如下，<code>p.move</code>是一个函数它的作用就是将一个点移动，然后我们通过<code>apply</code>方法把它借用给<code>circle</code>这个对象。将<code>circle</code>对象上的x/y属性进行变更，分别加2和1，实现了圆心的移动。很明显在这里 <strong><code>apply</code>方法描述的就是一个借用的功能</strong>.</p>
<p>为什么会把<code>apply/call</code>放在一起说呢，因为他们的功能并没有实质性的区别。只是在传入参数的时候，apply需要将参数以数组的形式进行传递，而call是将需要传入的参数一个一个跟在借用的对象后。下面一个小例子足以说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply1</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="comment">// return sum.apply(this,[num1,num2])</span></div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);<span class="comment">//利用函数的arguments对象</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.info(call1(<span class="number">10</span>, <span class="number">20</span>));<span class="comment">//30</span></div><div class="line"><span class="built_in">console</span>.info(call1(<span class="number">5</span>, <span class="number">10</span>));<span class="comment">//15</span></div></pre></td></tr></table></figure>
<p>可以看到我们在后两个函数中，可以直接使用sum方法。</p>
<ul>
<li><code>function.prototype.bind</code></li>
</ul>
<p>这里来看看ES5引入的<code>bind</code>，又有什么不同，还是和上面类似的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line">Point.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">stepX, stepY</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.x += stepX;</div><div class="line">    <span class="keyword">this</span>.y += stepY;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> circle = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>,<span class="attr">r</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> circleMove = p.move.bind(circle,<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">circleMove();</div><div class="line"><span class="built_in">console</span>.info(circle);<span class="comment">//&#123;x: 3, y: 3, r: 1&#125;</span></div><div class="line">circleMove(<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.info(circle);<span class="comment">//&#123;x: 5, y: 5, r: 1&#125;</span></div></pre></td></tr></table></figure></p>
<p>这里我使用了和 call 类似的调用方法，但是显然 bind 和 call 不一样，使用 bind 时，它会将我们绑定 this 后的函数引用返回，然后手动执行。可以看到的是，因为在这里我们绑定的对象的后面传入了x/y两个值，所以执行后坐标立即变化，并且在后来手动设置偏移量时也不再起到效果。<br>这样的相比于apply立即执行的好处时，我们可以使用定时器，例如:<code>setTimeout(circleMove,1000)</code>，延迟一秒后移动。</p>
<p>当然，每次只能移动固定的值也不是一件很好的事情，所以我们在使用 bind 的时候常常不会设置其默认参数， <code>var circleMove2 = p.move.bind(circle,);</code>,之后在执行函数时，再将参数传入<code>circleMove(3,4);</code>，这样就可以实现每次自定义偏移量了</p>
<p>这又引出了<code>call</code>/<code>apply</code>与<code>bind</code>的作用的另外一种说法： <strong>扩充作用域</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">color</span>:<span class="string">'black'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">color</span>:<span class="string">'yellow'</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">showColor();<span class="comment">//red</span></div><div class="line">showColor.call(obj);<span class="comment">//blue</span></div><div class="line">showColor.apply(obj1);<span class="comment">//black</span></div><div class="line">showColor.bind(obj2)();<span class="comment">//yellow</span></div></pre></td></tr></table></figure>
<p>可以看到这里都实现了一样的效果。值得说的是使用<code>call</code>、<code>aplly()</code>来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。</p>
<p>###　闭包</p>
<h4 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h4><p>先来看这样的一段代码，在chrome中找到<code>Scope</code>列表，可以看到，在作用域链上我们已经创建了一个闭包作用域！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">debugger</span>;</div><div class="line">    &#125;</div><div class="line">    b();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>闭包一个最简单的定义就是：闭包就是说在函数内部定义了一个函数，然后这个函数调用到了父函数内的相关临时变量，这些相关的临时变量就会存入闭包作用域里面.这就是闭包最基础的定义</p>
<h4 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h4><p>下面就来看一下闭包的一个基本特性保存变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(i++);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = add();</div><div class="line">f();<span class="comment">//1</span></div><div class="line">f();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>我们定义了一个 add 方法，执行完毕后会返回一个函数，接着我们就把这个函数赋值给了变量f，由于 add 函数也是返回一个函数，在我们每一次执行<code>f()</code>的时候，它引用了add内的变量i，并且保存在自己的闭包作用域内，所以一直输出执行的话，也会累加输出。</p>
<h4 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h4><p>需要我们记住的是 <strong>每次函数调用的时候创建一个新的闭包</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = add();</div><div class="line">fun();<span class="comment">//1</span></div><div class="line">fun();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>我们再来通过简单的例子看看另一个注意的地方：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a  = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> ff =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(a);</div><div class="line">    &#125;;</div><div class="line">    a = <span class="number">1214</span>;</div><div class="line">    <span class="keyword">return</span> ff;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = test();</div><div class="line">b();<span class="comment">//1214</span></div></pre></td></tr></table></figure>
<p>执行的结果是1214，从这里我们可以看到 <strong>闭包中局部变量是引用而非拷贝</strong>，其实这样的改变发散开来我们就可以知道，即使在这里变量 a 未在函数 ff 之前定义，而是<code>var a = 1214;</code>我们同样会得到同样的结果</p>
<h4 id="点击li显示对应编号案例解析"><a href="#点击li显示对应编号案例解析" class="headerlink" title="点击li显示对应编号案例解析"></a>点击li显示对应编号案例解析</h4><p>其实上面这些我是很晕的，来看一个我们实际在前端编程过程中经常遇到的问题。<br>我们有一个列表，分别为1/2/3，我们的需求是在点击不同的数字时，也能把它对应的编号弹出来。然后我们洋洋洒洒写下了这样的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"#list"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementById(<span class="string">"#list"</span>).getElementsByTagName(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++) &#123;</div><div class="line">        oLi[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一运行，发现懵了。怎么弹出来的都是3？不对啊，我不是用循环将值都传进去了吗？</p>
<p>如果你确实理解了上面的 <strong>闭包中局部变量是引用而非拷贝</strong>这一节中的两个案例的话，那么就应该能了解一些。</p>
<p>解析：在这里我们为每一个li的<code>onclick</code>事件 <strong>绑定</strong>了一个匿名函数，这个匿名函数就形成了一个闭包。这些匿名函数并不立即执行，而是在点击对应的li的时候才回去执行它。<br>而在这时就和上面的<code>a = 1214;</code>这个例子一样，此时的循环早已结束，i 就等于<code>oLi.length</code>，在我们点击不同的<code>li</code>时，闭包中引用的其实都是引用的同一个变量i自然弹出来的都是3，（这里不理解引用的都是用一个i的话，可以将<code>alert(i);</code>替换成<code>alert(i++);</code>，再到浏览器上去进行测试）</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementById(<span class="string">"#list"</span>).getElementsByTagName(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++) &#123;</div><div class="line">        oLi[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                alert(j);</div><div class="line">            &#125;;</div><div class="line">        &#125;)(i);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">/*</span></div><div class="line">(function() &#123;</div><div class="line">    var oLi = document.getElementById("#list").getElementsByTagName("li");</div><div class="line">    for (var i = 0; i &lt; oLi.length; i++) &#123;</div><div class="line">        (function(j)&#123;</div><div class="line">            oLi[i].onclick= function()&#123;</div><div class="line">                alert(j);</div><div class="line">            &#125;;</div><div class="line">        &#125;)(i);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到这里给出了两个简单的写法，但实际上除了写法不同之外、闭包包含范围、内容也不太一样（有兴趣的可以打开chrome调试工具看看），但是达到的效果是一样的。这样我们就为每个<code>li</code>的<code>onclick</code>事件的匿名函数，都保存下了自己闭包变量。就可以实现在点击每个li的时候弹出对应的标号了。（还可以将<code>alert(j);</code>替换成<code>alert(j++);</code>欣赏一下点击不同li时的累加效果）</p>
<p>当然如果你只是想要记住一些标号这么简单的事情，其实还可以将变量保留于元素节点上，也能达到一样的效果，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementById(<span class="string">"#list"</span>).getElementsByTagName(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++) &#123;</div><div class="line">        oLi[i].flag = i;</div><div class="line">        oLi[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.flag);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>如果有错误之处，请指正。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解-Javascript中的this&quot;&gt;&lt;a href=&quot;#理解-Javascript中的this&quot; class=&quot;headerlink&quot; title=&quot;理解 Javascript中的this&quot;&gt;&lt;/a&gt;理解 &lt;code&gt;Javascript&lt;/code&gt;中的&lt;
    
    </summary>
    
      <category term="JS深度学习" scheme="http://guowenfh.github.io/categories/JS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://guowenfh.github.io/tags/JS/"/>
    
      <category term="百度前端技术学院" scheme="http://guowenfh.github.io/tags/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript函数学习笔记</title>
    <link href="http://guowenfh.github.io/2016/07/31/javascriptFunctionBasic/"/>
    <id>http://guowenfh.github.io/2016/07/31/javascriptFunctionBasic/</id>
    <published>2016-07-31T12:03:45.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数式一块javascript代码，定义一次，可以被多次调用与执行，JS中的函数也是对象，所以JS函数可以像其他对象那样操作，和传递，所以也称函数对象<br>函数的参数列表相当于函数的人口，<code>return</code>相当于函数的出口，函数本身就是一种数据类型，函数是可以嵌套定义的。</p>
</blockquote>
<h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><p>####　定义函数的方式</p>
<p>有三种方式可以定义函数。并且有着如下区别：</p>
<table>
<thead>
<tr>
<th>定义方式：</th>
<th><code>function</code> 语句（函数声明）</th>
<th><code>Function</code> 构造函数</th>
<th>函数表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>解析时机：</td>
<td>优先解析(声明前置)</td>
<td>顺序解析</td>
<td>顺序解析(声明提前，赋值不提前)</td>
</tr>
<tr>
<td>允许匿名：</td>
<td>有名</td>
<td>匿名</td>
<td>匿名</td>
</tr>
<tr>
<td>形式：</td>
<td>句子</td>
<td>表达式</td>
<td>表达式</td>
</tr>
<tr>
<td>性质：</td>
<td>静态</td>
<td>动态</td>
<td>静态</td>
</tr>
<tr>
<td>作用域：</td>
<td>具有函数的作用域</td>
<td>顶级函数(顶级作用域)</td>
<td>具有函数作用域</td>
</tr>
</tbody>
</table>
<p>主要有下面两个需要注意的地方：</p>
<ul>
<li>理解<code>Function</code> 构造函数的顶级作用域，直接看代码就好：很直观就可以表示出来</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a  = <span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.info(a)"</span>);</div><div class="line">    func();</div><div class="line">&#125;</div><div class="line">test();<span class="comment">//1;</span></div></pre></td></tr></table></figure>
<ul>
<li>函数表达式的多种创建方式：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最简单的形式，将函数赋值给一个变量</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="comment">//do ..</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 立即执行匿名函数表达式IIFE</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//do ..</span></div><div class="line">&#125;)();</div><div class="line"><span class="comment">// 将函数当成返回值</span></div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//do ..</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//命名式函数表达式NFE</span></div><div class="line"><span class="keyword">var</span> add  = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="comment">// do..</span></div><div class="line">    <span class="comment">// 只在foo函数内部可以使用foo这个名称(用途如：递归调用)（在新版浏览器下可用）</span></div><div class="line">    <span class="comment">// 外部访问不到foo这个函数名</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><blockquote>
<p>在JS中函数的参数分为形式参数和实际参数两个概念</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c,d</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(test.length)<span class="comment">//4</span></div><div class="line">    <span class="keyword">return</span> a+b+c;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.info(test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))<span class="comment">//60</span></div><div class="line"><span class="built_in">console</span>.log(test.length)<span class="comment">//4</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);<span class="comment">//3,表示实际接受的参数个数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//10，传进来的第一个参数===a</span></div></pre></td></tr></table></figure>
<p>在 <strong>函数内部</strong> ，JS使用了一个特别的变量<code>arguments</code>的 <strong>类数组对象</strong>（以后再来说这个问题），用来接受传入函数的实际参数列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.info(a,b,c)</div><div class="line">&#125;</div><div class="line">arg(<span class="number">143</span>,<span class="number">456</span>,<span class="number">6</span>)<span class="comment">//1 456 6</span></div></pre></td></tr></table></figure>
<p>普通模式下可以直接对于<code>arguments</code>对象进行更改，上面的代码就是一个很直观的例子，我们直接更改了第一个参数的值，<strong>但建议不要去试图更改<code>arguments</code>对象的属性</strong>，不符合规范。<br>注：严格模式下<code>arguments</code>对象是实参的一个副本，所以上面的改动不会生效(自行尝试)</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>什么是构造函数？</p>
<p>其实构造函数只是普通函数的一个变种，它可以当成普通的函数方式调用，也能通过<code>new</code>关键字来调用。 在<code>Javascript</code>中通过 <code>new</code> 关键字方式调用的函数都被认为是构造函数。<br>在构造函数内部（ 也就是被调用的函数内） <code>this</code> 指向新创建的对象<code>Object</code>。 这个新创建的对象的 <code>prototype</code> 被指向到构造函数的 <code>prototype</code>。<br>如果被调用的函数没有显式的 <code>return</code> 表达式，则隐式的会返回 <code>this</code> 对象(也就是新创建的对象)。</p>
<p>这就来看看实际中不同情况下的区别：</p>
<ol>
<li>使用<code>new</code>关键字吗，不指定<code>return</code>语句</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.father = <span class="string">'allen'</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.father);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> hong = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.info( <span class="keyword">new</span> Person());<span class="comment">//Person &#123;father: "allen"&#125;</span></div><div class="line">hong.getFatherName();<span class="comment">//allen</span></div></pre></td></tr></table></figure>
<ol>
<li>使用<code>new</code>关键字，并且指定<code>return</code>语句</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.father = <span class="string">'allen'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">"1"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.father);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> hong = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.info( hong);<span class="comment">//Person &#123;father: "allen"&#125;</span></div><div class="line">hong.getFatherName();<span class="comment">//allen</span></div><div class="line"></div><div class="line"><span class="comment">//把return的值换成一个对象：</span></div><div class="line"><span class="comment">//return "1";-----------&gt;return &#123;a:1&#125;;或者return new String("12");</span></div><div class="line"><span class="keyword">var</span> hong = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.info( hong);<span class="comment">//Object &#123;a: 1&#125;</span></div><div class="line">hong.getFatherName();<span class="comment">//[脚本错误]</span></div></pre></td></tr></table></figure>
<ol>
<li>不使用<code>new</code>关键字，当成普通函数直接调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.father = <span class="string">'allen'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">Person.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.father);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> bai = Person();</div><div class="line"><span class="built_in">console</span>.info(bai);<span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.info(father);<span class="comment">//allen</span></div><div class="line">bai.getFatherName();<span class="comment">//[脚本错误]</span></div></pre></td></tr></table></figure>
<p>通过这三段不同情况的示例代码，应该可以发现一些区别：</p>
<ol>
<li>使用<code>new</code>关键字吗，不指定<code>return</code>语句时，将隐式的会返回 <code>this</code> 对象(返也就是新创建的对象)。</li>
<li>使用<code>new</code>关键字，并且指定<code>return</code>语句时，需分为两种情况：<ul>
<li>返回值为标准类型，显式的 <code>return</code> 表达式将<strong>不会</strong>影响返回结果</li>
<li>返回值为对象，将直接返回你显式设置的对象</li>
</ul>
</li>
<li>不使用<code>new</code>关键字，当成普通函数直接调用时，<code>this</code>指向全局对象 window，所以内部this指定的属性与方法，全部都暴露到全局，导致全局变量污染。prototype上的方法不起效果(当然你要是这样的形式指定了return返回的内容，它自然会原样返回啦！)</li>
</ol>
<h4 id="工厂模型"><a href="#工厂模型" class="headerlink" title="工厂模型"></a>工厂模型</h4><p>为了不使用<code>new</code>关键字，构造函数必须显式的返回一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, sex</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.name = name;</div><div class="line">    obj.age = age;</div><div class="line">    <span class="keyword">var</span> private = <span class="number">2</span>;<span class="comment">//私有外部不可访问</span></div><div class="line">    obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">    obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> private;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">"小红"</span>,<span class="number">21</span>,<span class="string">"女"</span>)</div><div class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">"小国"</span>,<span class="number">22</span>,<span class="string">"男"</span>)</div><div class="line"><span class="built_in">console</span>.info(p1.name);<span class="comment">//小红</span></div><div class="line"><span class="built_in">console</span>.info(p2.age);<span class="comment">//22</span></div><div class="line">p2.sayName();<span class="comment">//小国</span></div></pre></td></tr></table></figure>
<p>这就是一个简单的工厂模型，使用或者不使用<code>new</code>关键字没有功能性的区别。这样的方式比起 <code>new</code>的调用方式不容易出错，并且可以充分利用 <strong>私有变量</strong>带来的便利， 但是也有下面这样的问题</p>
<ol>
<li>占用更多的内存，因为新创建的对象不能共享原型上的方法。</li>
<li>为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
</ol>
<p>这一篇博客最主要是对于函数学习的笔记，不过用自己的话来描述总描述的还不够清晰。<br>有错误之处请指出！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;函数式一块javascript代码，定义一次，可以被多次调用与执行，JS中的函数也是对象，所以JS函数可以像其他对
    
    </summary>
    
      <category term="JS深度学习" scheme="http://guowenfh.github.io/categories/JS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://guowenfh.github.io/tags/JS/"/>
    
      <category term="百度前端技术学院" scheme="http://guowenfh.github.io/tags/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数组方法学习笔记</title>
    <link href="http://guowenfh.github.io/2016/07/24/JavaScript-ArrayMethod/"/>
    <id>http://guowenfh.github.io/2016/07/24/JavaScript-ArrayMethod/</id>
    <published>2016-07-24T12:46:15.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>在ECMAScript中数组是非常常用的引用类型了。ECMAScript所定义的数组和其他语言中的数组有着很大的区别。那么首先要说的就是数组也是一种对象。</p>
<p>特点:</p>
<ul>
<li>在JS中,”数组”即一组数据的集合长度可变，元素类型也可以不同！</li>
<li>数组长度随时可变！随时可以修改！（length属性）</li>
</ul>
</blockquote>
<p>一般来说我们定义数组的方法很简单，直接使用<code>[]</code>即可，当然也可以使用<code>new Array()</code>这样的构造函数的形式，不过并不常用。对于数组本身本没有太多可以说的东西，还是直接来过一遍它的方法</p>
<h3 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h3><ol>
<li><p><code>push</code>：向数组尾部添加元素（可多个）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr =[];</div><div class="line"><span class="keyword">var</span> result = arr.push(<span class="number">1</span>,<span class="literal">true</span>);</div><div class="line"><span class="comment">// arr =[1,true] </span></div><div class="line"><span class="comment">// result=2;push方法返回值为新数组的长度</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>pop</code>：从数组尾部移除一个元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr =[<span class="number">1</span>,<span class="literal">true</span>];</div><div class="line"><span class="keyword">var</span> result = arr.pop();</div><div class="line"><span class="comment">// arr=[1]</span></div><div class="line"><span class="comment">// result = true;pop方法返回值为被移除的元素</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>shift</code>：从数组头部删除一个元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="keyword">new</span> <span class="built_in">Date</span>()];</div><div class="line"><span class="keyword">var</span> result = arr.shift();<span class="comment">//</span></div><div class="line"><span class="comment">// arr =[2, true, Fri May 20 2016 00:50:33 GMT+0800 (中国标准时间)] </span></div><div class="line"><span class="comment">// result = 1;shift方法返回值为被移除的元素</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>unshift</code>：向数组头部添加元素（可多个）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="keyword">var</span> result  = arr.unshift(<span class="number">1</span>,<span class="number">2</span>,<span class="literal">false</span>);</div><div class="line"><span class="comment">// arr = [1, 2, false]</span></div><div class="line"><span class="comment">// result = 3 ; unshift方法返回新数组的长度</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>splice</code>：数组截取/插入的方法（操作数组本身）</p>
<ol>
<li>第一个参数：截取的起始位置</li>
<li>第二个参数：表示截取的个数</li>
<li>第三个参数以后：从截取处插入新的元素（可多个）<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line"><span class="comment">// arr = [1, 3, 4, 5, 4, 5];splice方法操作直接操作数组本身</span></div><div class="line"><span class="comment">// result = [2,3];splice方法返回被截取的元素</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>slice</code>：数组截取（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.slice(<span class="number">2</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];不操作数组本身</span></div><div class="line"><span class="comment">// result = [3,4];slice方法返回被截取的元素</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>concat</code>：链接两个数组的方法（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="literal">true</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr1.concat(arr2); </div><div class="line"><span class="comment">// arr1 = [1, 2, 3];</span></div><div class="line"><span class="comment">// arr2 = [true, 5];</span></div><div class="line"><span class="comment">// result = [1, 2, 3, true, 5];concat方法返回链接后的新数组</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>join</code>：在每个元素之间加入内容（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.join(<span class="string">"-"</span>);</div><div class="line"><span class="comment">// arr = [1, 2, 3, 4, 5];</span></div><div class="line"><span class="comment">// result = "1-2-3-4-5"; join方法返回每个元素加入内容后的字符串</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>sort</code>：排序（直接操作数组本身）</p>
<ul>
<li>sort方法默认按照字符串形式的utf编码进行排序，需要确切的正序或倒序排序时，需要写入自己的函数 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">345</span>,<span class="number">23</span>,<span class="number">22</span>,<span class="number">10</span>,<span class="number">9</span>];</div><div class="line"><span class="keyword">var</span> result1   = arr.sort();</div><div class="line"><span class="comment">// arr = [1, 10, 22, 23, 345, 9]</span></div><div class="line"><span class="comment">// result1 = [1, 10, 22, 23, 345, 9]sort方法返回排序后的数组</span></div><div class="line"><span class="keyword">var</span> result2   = arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a-b;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// result2 = [1, 9, 10, 22, 23, 345];正确的从小到大排列</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>reverse</code>：数组反转(直接操作数组本身)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">324</span>,<span class="number">543</span>,<span class="number">10</span>,<span class="number">9</span>];</div><div class="line"><span class="keyword">var</span> result = arr.reverse();</div><div class="line"><span class="comment">// arr = [9, 10, 543, 324, 12];</span></div><div class="line"><span class="comment">// result = [9, 10, 543, 324, 12]; //返回反转后的数组</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>indexOf</code>:正序查找元素的索引（0开始）</p>
<ul>
<li>只有一个参数时，表示待查找的元素</li>
<li>两个参数时，第一个参数表示表示待查找的元素，<br>第二个参数从第几个元素开始查<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> result1 = arr.indexOf(<span class="number">4</span>)</div><div class="line"><span class="keyword">var</span> result2 = arr.indexOf(<span class="number">4</span>,<span class="number">4</span>)</div><div class="line"><span class="comment">// arr = [1,2,3,4,5,4,3,2,1];</span></div><div class="line"><span class="comment">// result1 = 3；返回值为查找到的元素索引</span></div><div class="line"><span class="comment">// result2 = 5</span></div><div class="line"><span class="comment">// 没有返回-1</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>lastIndexOf</code>:倒序版本：倒序查找元素的索引（最后一个元素开始）</p>
<ul>
<li>只有一个参数时，表示待查找的元素</li>
<li>两个参数时，第一个参数表示待查找的元素，第二个参数表示从倒数第几个元素开始查<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> result1 = arr.lastIndexOf(<span class="number">4</span>)</div><div class="line"><span class="keyword">var</span> result2 = arr.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>)</div><div class="line"><span class="comment">// arr = [1,2,3,4,5,4,3,2,1];</span></div><div class="line"><span class="comment">// result1 = 5；返回值为查找到的元素索引</span></div><div class="line"><span class="comment">// result2 = 3</span></div><div class="line"><span class="comment">// 没有返回-1</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>forEach</code>：循环数组的每一个元素，并且对每一项执行一个方法。没有返回值（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item+<span class="number">1</span>; </div><div class="line">&#125;)</div><div class="line"><span class="comment">// arr = [1, 2, 3, 4, 5];</span></div><div class="line"><span class="comment">// result = undefined;forEach方法没有返回值</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>map</code>：循环数组的每一个元素，并且对每一项执行一个方法，执行完毕后，新的数组返回（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item+<span class="number">1</span>; </div><div class="line">&#125;)</div><div class="line"><span class="comment">// arr = [1, 2, 3, 4, 5];</span></div><div class="line"><span class="comment">// result = [2, 3, 4, 5, 6];map方法返回运行函数后的新数组</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>filter</code>：对于数组的每一个元素，进行一个函数的运行，给定条件去执行，返回过滤后的结果（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item&gt;<span class="number">2</span>; </div><div class="line">&#125;)</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];</span></div><div class="line"><span class="comment">// result = [3,4,5];返回满足条件的值</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>every</code>：对于数组的每一个元素都执行一个函数，如果都返回<code>true</code>,最后则返回<code>true</code>；如果有一个返回<code>false</code>,最后结果返回<code>false</code>.（不操作数组本身）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result1 = arr.every(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> result2 = arr.every(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];</span></div><div class="line"><span class="comment">// result1 = false;不全部满足条件</span></div><div class="line"><span class="comment">// result2 = true;全部满足条件</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>some</code>：对于数组的每一个元素都执行一个函数，如果有一项返回<code>true</code>,最后则返回<code>true</code>；如果每一项返回<code>false</code>,最后结果才返回<code>false</code>.（不操作数组本身）（与上一个<code>every</code>相反）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result1 = arr.some(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item&gt;=<span class="number">5</span>;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> result2 = arr.some(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">item,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item&lt;<span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];</span></div><div class="line"><span class="comment">// result1 = true;不全部满足条件</span></div><div class="line"><span class="comment">// result2 = false;每一项都返回false</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>reduce</code>:最终构建一个返回值，接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="comment">/**</span></div><div class="line"> * perv:前一个值</div><div class="line"> * cur：当前值</div><div class="line"> * index：当前索引位置</div><div class="line"> * arr：原数组</div><div class="line"> **/</div><div class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">perv,cur,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> perv +cur;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];</span></div><div class="line"><span class="comment">// result = 15;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>reduceRight</code>:倒序版本：最终构建一个返回值，<br>遍历的起始位置不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="comment">/**</span></div><div class="line"> * perv:前一个值</div><div class="line"> * cur：当前值</div><div class="line"> * index：当前索引位置</div><div class="line"> * arr：原数组</div><div class="line"> **/</div><div class="line"><span class="keyword">var</span> result = arr.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">perv,cur,index,arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> perv +cur;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// arr = [1,2,3,4,5];</span></div><div class="line"><span class="comment">// result = 15;</span></div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在ECMAScript中数组是非常常用的引用类型了。ECMAScript所定义的数组和其他语言中的数组有着很大的区
    
    </summary>
    
      <category term="前端技术" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://guowenfh.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域学习笔记</title>
    <link href="http://guowenfh.github.io/2016/07/08/JavaScript-scopeChain/"/>
    <id>http://guowenfh.github.io/2016/07/08/JavaScript-scopeChain/</id>
    <published>2016-07-07T16:45:23.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>无论什么语言中，作用域都是一个十分重要的概念，在JavaScript中也不例外，作用域定义了变量或者函数有权访问的范围，决定了它们各自的行为。要理解JavaScript中的作用域首先就要知道：在<code>let</code>出现之前，JS中变量的作用域只有两种：全局作用域和局部作用域。（本文也只讨论这两种作用域）</p>
</blockquote>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局作用域是最外围的一个执行环境，可以在代码的任何地方访问到。在浏览器中，我们的全局作用域就是<code>window</code>。因此在浏览器中，所有的全局变量和函数都是作为<code>window</code>对象的属性和方法创建的。</p>
<p>下面就来看看全局作用域的创建方式：</p>
<ol>
<li>全局变量与全局函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"小红"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherName = <span class="string">"小黑"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(name)</div><div class="line">        <span class="built_in">console</span>.info(anotherName)</div><div class="line">    &#125;</div><div class="line">    showName();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(name);<span class="comment">//小红</span></div><div class="line"><span class="built_in">console</span>.info(anotherName);<span class="comment">//【脚本出错】</span></div><div class="line">doSomething();<span class="comment">//小红---小黑</span></div><div class="line">showName();<span class="comment">//【脚本出错】</span></div></pre></td></tr></table></figure>
<p>通过代码可以很清楚的看出来，我在前面所说的 <strong>作用域定义了变量或者函数有权访问的范围</strong> ，在这里我们定义了一个全局的变量<code>name</code>与全局函数<code>doSomething()</code>，他可以在任何地方被直接访问。但是我们又在函数内部创建了变量<code>anotherName</code>与函数<code>showName()</code>，通过代码中的调用情况可以发现，我们在外部调用它时提示【脚本出错】，因为他们处于局部作用域内（稍后讲），而 <strong>外部环境不能访问内部环境的任何变量与函数</strong>。这就涉及到了作用域的概念(稍后讲)</p>
<ol>
<li>未声明直接定义的变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fullName = <span class="string">"小红"</span>;</div><div class="line">    anotherName = <span class="string">"小黑"</span>;</div><div class="line">    <span class="built_in">console</span>.info(fullName)</div><div class="line">&#125;</div><div class="line">showName();<span class="comment">//小红</span></div><div class="line"><span class="built_in">console</span>.info(anotherName);<span class="comment">//小黑</span></div><div class="line"><span class="built_in">console</span>.info(fullName);<span class="comment">//【脚本出错】</span></div></pre></td></tr></table></figure>
<p>在这样的情况下，变量<code>anotherName</code>拥有全局作用域，而<code>fullName</code>在函数外部无法访问到。（注：在高程中明确说明，不声明而直接初始化变量是错误做法，应该避免这样的情况<code>严格模式下，初始化未声明的变量将报错</code>）</p>
<ol>
<li>所有window对象上的属性都具有全局作用</li>
</ol>
<p>这个实际上在上面已经提到了：<strong>所有的全局变量和函数都是作为<code>window</code>对象的属性和方法创建的。</strong>，自然<code>window</code>对象它本身所具有的属性和方法，同样是处于全局作用域，例如：<code>window.location</code>，<code>window.name</code>等等。</p>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>其实在上面的代码中，为了展示全局作用域的效果，我们就已经创造了局部作用域。局部作用域和全局作用域正好相反，局部作用域一般只在固定的代码片段内可访问到，最常见的就是函数内部，所以在很多地方就会有人把它称为函数作用域。（记住<code>let</code>之前无块级作用域）。我们再来看一下第一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"小红"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherName = <span class="string">"小黑"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(name)</div><div class="line">        <span class="built_in">console</span>.info(anotherName)</div><div class="line">    &#125;</div><div class="line">    showName();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.info(anotherName);<span class="comment">//【脚本出错】</span></div><div class="line">showName();<span class="comment">//【脚本出错】</span></div></pre></td></tr></table></figure>
<p>在这段代码中变量 <code>anotherName</code>,与函数 <code>showName()</code>，都拥有局部作用域。因此它不能被外部所访问，那么问题就来了，为什么全局变量他就能在局部作用域内被访问到呢？这就是 JavaScript 中的作用域链概念！</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在JS中:”一切皆是对象, 函数也是”。</p>
<p>在 JavaScript 中，每个函数都有着自己的作用域，在每次调用一个函数的时候 ，就会进入一个函数内的作用域，而当函数执行返回以后，就返回调用前的作用域。</p>
<p>当代码在一个作用域内执行时，就会根据其上下文创建一个作用域链，该作用域链的用途就是控制当前作用域对于内所有的变量与函数的有序访问。作用域链的最前端，始终都是当前执行代码所在的作用域的变量对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"小红"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(name ===<span class="string">"小红"</span>)&#123;</div><div class="line">        name=<span class="string">"小黑"</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        name =<span class="string">"小红"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">changeName();</div><div class="line"><span class="built_in">console</span>.info(<span class="string">"新名字:"</span>+name);<span class="comment">//小黑</span></div></pre></td></tr></table></figure>
<p>在这个例子中，<code>changName()</code>被定义在全局作用域下，他的作用域链包含着包含两个对象：1.它本身的变量对象(函数都会包含<code>arguments</code>对象)，2.全局环境对象。之所以能在函数内部访问到变量<code>name</code>,就是因为在它的作用域中，能找到它。（<strong>JS的标识符解析，是沿着作用域链一级一级的查找搜索的过程，从作用域链的最前端开始直到全局环境，最终没有查找到时将报错。</strong>）我们再回过头来稍微改一下第一段代码：并且看看他们能访问到那些变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"小红"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherName = <span class="string">"小黑"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> author =<span class="string">"三省吾身丶丶"</span>;</div><div class="line">        <span class="built_in">console</span>.info(name)</div><div class="line">        <span class="built_in">console</span>.info(anotherName)</div><div class="line">        <span class="comment">// 在这里可以访问到 name 、anotherName 、author</span></div><div class="line">    &#125;</div><div class="line">    showName();</div><div class="line">    <span class="comment">// 在这里可以访问到 name anotherName ,不能访问到 author</span></div><div class="line">&#125;</div><div class="line">doSomething();</div><div class="line"><span class="comment">// 在这里只能访问到 name</span></div></pre></td></tr></table></figure>
<p>要想理解这种作用域其实也很简单，作用域就像是一架 <strong>每一个台阶都是相对封闭（同级），并且只能上不能下的梯子</strong>，在越底层的台阶上，它能走的步数越多（作用域链越长）。为了找到它想要的东西，就开始爬台阶，每爬一步台阶，都能看到这一级台阶上有什么东西，直到最顶上的那一阶。（找到了就带回去一起玩耍，玩完了之后还得换回去，要是最后都没找到就掉下去摔死了）</p>
<h3 id="坑与示例解析"><a href="#坑与示例解析" class="headerlink" title="坑与示例解析"></a>坑与示例解析</h3><p>在了解坑之前，其实只要记住权威指南里面的一句话，就可以躲过很多这方面的坑了，那就是：<strong>JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里</strong></p>
<p>下面就来看看这一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'小红'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'小黑'</span>;</div><div class="line">    showName();</div><div class="line">&#125;</div><div class="line"></div><div class="line">show();</div></pre></td></tr></table></figure>
<p>结果会是什么呢？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">小红</div></pre></td></tr></table></figure>
<p>如果你记住并且理解了上面的话，那么应该可以得到这个结果。用作用域链的角度解析：执行<code>show()</code>函数时，进入<code>function show(){}</code>的作用域内，然后执行<code>showName()</code>函数，再进入到<code>function showName(){}</code>的作用域内，要输出<code>name</code>，就在当前作用域找，但是找不到，然后就向上爬一层，在全局环境中找到了<code>var name = &#39;小红&#39;;</code>，所以<code>show()</code>就输出了小红。</p>
<p>再来看一个这个例子的改动版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'小红'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'小黑'</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.info(name);</div><div class="line">    &#125;</div><div class="line">    showName();</div><div class="line">&#125;</div><div class="line">show();</div></pre></td></tr></table></figure>
<p>结果是：<code>小黑</code></p>
<p>解析：执行<code>show()</code>函数时，进入<code>function show(){}</code>的作用域内，然后执行<code>showName()</code>函数，再进入到<code>function showName(){}</code>的作用域内，要输出<code>name</code>，就在当前作用域找，发现本身找不到，就向上爬一层到了<code>show()</code>里面，发现已经找到了<code>var name = &#39;小黑&#39;;</code>，那么就停止查找，输出了<code>小黑</code><br>。</p>
<p>先到这，不知道有没有对作用域有了更多的了解呢？感觉有些地方还了解的不够透彻，希望在开发项目的过程中能有更深的理解。</p>
<p>如果有错误之处，请指正。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无论什么语言中，作用域都是一个十分重要的概念，在JavaScript中也不例外，作用域定义了变量或者函数有权访问的范围，决定了它们各自的行为。要理解JavaScript中的作用域首先就要知道：在&lt;code&gt;let&lt;/code&gt;出现之前，JS中变量的
    
    </summary>
    
      <category term="JS深度学习" scheme="http://guowenfh.github.io/categories/JS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://guowenfh.github.io/tags/JS/"/>
    
      <category term="百度前端技术学院" scheme="http://guowenfh.github.io/tags/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>思想汇报</title>
    <link href="http://guowenfh.github.io/2016/07/03/thoughtReport-2016-07-03/"/>
    <id>http://guowenfh.github.io/2016/07/03/thoughtReport-2016-07-03/</id>
    <published>2016-07-03T09:14:29.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>闲来无事，翻了翻朋友圈，看到自己年初定下的几个小目标，突然想到原来王自如的思想汇报，我觉得自己也应该要反思一下自己，正好写下来做一个沉淀。</p>
</blockquote>
<p>时间真快啊，到写博客的时候才发现上一篇博客还是三月份在广州实习的时候写的，到今天已经有96天了。沉默了那么长一段时间，也并没有憋什么大招，不是太满意，现在重新开始写，最低产量一个星期一篇吧，不过什么都可以写，都是自己心境的一个记录。</p>
<p>正好2016年已经过去一半了，那就先从年初定下的目标开始说起吧</p>
<h3 id="说说目标"><a href="#说说目标" class="headerlink" title="说说目标"></a>说说目标</h3><p>还记得当时是15年最后一天，本来东拼西凑写了千把字的总结，因为太散就只留下了下面这几个目标：</p>
<blockquote>
<ol>
<li>前端实习，答辩，工作。</li>
<li>前端技术与编程思想的学习。</li>
<li>继续消除自卑心理，提升自信，积极面对。</li>
<li>多看书，先定个最低目标吧，30本。</li>
<li>写作表达，开口说话，冷场说话，脸皮薄也要说话，挨打也要说话。</li>
<li>尽心尽力把每一件事情最好，但求问心无愧。</li>
</ol>
</blockquote>
<p>半年时间，对自己不够满意，但也算是完成了一些吧，如下：</p>
<ul>
<li>结束广州的前端实习，到重庆的毕业答辩，再到现在杭州的前端工作，辗转几个地方，第一个目标算是完成了。</li>
<li>书这方面，无营养的网文看了不少，正儿八经的书就有点惨不忍睹了，看完的有：《大学之路（上、下册）》、《Web全栈开发师的自我修养》、《自卑与超越》、《慕课革命》。确实完成的不像话，后面这半年得加油了，书买回来就要看，自己定下的目标还是要去完成</li>
<li>其他的几个目标其实说的比较泛泛，不是太好评价。<ul>
<li>前端技术和编程思想方面，其实个人觉得进步不多，不过在和老友一起做一个外包项目之后，明白以及确定以解决问题为完成工作的第一要务，而后再去考虑其他的种种因素，这也是一个进步吧！</li>
<li>关于自卑和说话，现在已经好很多了，在分享与提出质疑中继续加油吧！大不了就是挨打不是么？</li>
</ul>
</li>
</ul>
<p><strong>尽心尽力把每一件事情最好，但求问心无愧。</strong>，这个继续加油吧！</p>
<p>不知不觉中学习前端到这个月已经整整一年时间，算是正式跨入了互联网的行当里面。</p>
<p>其实第一次接触编程是大一，当时买了本C语言的书，对着教程就开始学，然后…就从入门到放弃了，直到去年再次想学习编程，接触到前端，因为易入门、浏览器的直观显示（至今我还更喜欢调界面，为了1px耗上个半天，毕竟处女座嘛）、再到了解到响应式网页开发的强大，才真正的喜欢上了编程。前路漫漫，继续加油！</p>
<h3 id="思考和感悟"><a href="#思考和感悟" class="headerlink" title="思考和感悟"></a>思考和感悟</h3><ol>
<li><p>其实每次写博客都希望自己写的很好，写一些别人没有写过的东西出来，但是现在还没达到那样的水平，然后一味的想，导致根本没有产出。其实产出可以是对自己的，你把别人的东西学会、用出来，把过程记录下来，然后学到的东西不就是自己的了么？所以现在改变策略了，事无巨细，我更多的可能会把博客当成笔记来使用，只是把记的笔记使用讲述的方式来帮助我理解。</p>
</li>
<li><p>这半年看书确实看的有点少了，当初刚学前端的时候，学校安排到医院实习，除去正常的医院工作外，在办公室就是看书了。哦，不对，抄书。css一个一个属性抄过去，js秘密花园抄了一遍，结果后来开始找实习之后就没有这样了，看博客、敲代码。做了很多重复的事情，现在要改变策略了，又在知乎上看到CSS魔法在半年前对我说的：<code>疯狂啃书，野蛮生长！</code>，这半年没这样做到，就像乔老爷子说的那句话 <code>Stay Hungry. Stay Foolish.</code>，保持这种饥饿感，保持一种初学者的心态， 那么下半年就要加油了。</p>
</li>
<li><p>我学习有一个很大的问题想得太多，做的太少，可能真的是我一个特别需要去改进的地方吧，就像完成工作一样，首先一定是要把工作完成，然后再想着怎么去优化，改进。在这个新型技术一浪接着一浪的时代，一定要快速开发，功能都没有完成，想着优化有什么用呢?</p>
</li>
<li><p>质疑和沟通很重要，有什么问题在尝试过后，解决不了就和别人沟通，说不定是别人的问题，或者别人可能很轻松的帮你解决，记得把问题的解决记录下来。不要一个人闷着，做太多的额外功，等到别人催你之后再去和别人沟通，这时，项目的进度就被你拉下来了，这样不好。</p>
</li>
<li><p>做事情积极主动一点，手上工作完成了就想想能不能优化，和同事一起商量一下有没有更好的解决方案，同事那边有什么是你能帮上忙的，不要被动的被推着走，积极主动点没错的。</p>
</li>
<li><p>记下这句可以警醒的话</p>
<blockquote>
<p>这才是真正的人生，每个人都按照惯性进步或者滑落，更多是在煮沸温水中逐渐死去的青蛙，愚昧无知到连跳出去的欲望都欠奉。</p>
</blockquote>
</li>
<li><p>嗯，还有都快130了。。。。这么胖，你能忍? 多跑步健身减肥，健康是最大的本钱，平安是福，对人对己都是。</p>
</li>
</ol>
<p>今天就这样吧，最重要的是：</p>
<p><strong>坚持去坚持。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;闲来无事，翻了翻朋友圈，看到自己年初定下的几个小目标，突然想到原来王自如的思想汇报，我觉得自己也应该要反思一下自己，正好写下来做一个沉淀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间真快啊，到写博客的时候才发现上一篇博客还是三月份在广州实习的时
    
    </summary>
    
      <category term="生活" scheme="http://guowenfh.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思想汇报" scheme="http://guowenfh.github.io/tags/%E6%80%9D%E6%83%B3%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（六）配合vue-router实现SPA</title>
    <link href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/"/>
    <id>http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/</id>
    <published>2016-03-28T05:57:57.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a>，在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<p>在上面的练习当中我们已经成功的加载了一个<code>.vue</code>格式的单文件组件，并且实现了在使用vue情况下的自动刷新。</p>
<p>但是我们最终的目的还是要实现单页面应用程序，这个时候我们就必不可少的需要使用到路由管理器来进行SPA的开发，vue官方为我们提供了一个官方库<a href="https://github.com/vuejs/vue-router" target="_blank" rel="external">vue-router</a>，并且配有对应的<a href="http://vuejs.github.io/vue-router/zh-cn/index.html" target="_blank" rel="external">中文文档</a>。关于里面的内容大家自行前去观看。在这里，只会把我们需要的东西拿出来讲。</p>
<h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><blockquote>
<p><a href="http://cn.vuejs.org/guide/components.html" target="_blank" rel="external">官网对于组件讲解</a></p>
</blockquote>
<p>在<code>Vue</code>中定义一个组件非常简单，只需要一对<strong>自定义标签</strong>，在其中填入内容就可以进行我们的组件编写了，然后使用<code>Vue.component()</code>去注册我们的组件下面来看一个例子，来直观的看看vue的组件。</p>
<h3 id="组件入门"><a href="#组件入门" class="headerlink" title="组件入门"></a>组件入门</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 自定义标签作为组件名称 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 复用 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">        <span class="comment">// 定义并且注册组件</span></div><div class="line">        <span class="comment">// 在官方的示例中使用 Vue.extend(&#123;&#125;)先注册了一个定义模板，再引用，看个人喜好吧</span></div><div class="line">        Vue.component(<span class="string">"my-component"</span>, &#123;</div><div class="line">            template:<span class="string">"&lt;h2&gt;hello Vue component&lt;/h2&gt;"</span></div><div class="line">        &#125;)</div><div class="line">        <span class="comment">// 创建根实例</span></div><div class="line">        <span class="comment">// 在这里 定义并且注册组件 必须创建根实例前，不然会报错，因为解析顺序的问题？</span></div><div class="line">        <span class="keyword">new</span> Vue(&#123;</div><div class="line">            el:<span class="string">"#app"</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面就是最简单的定义组件的方式，<strong><code>template</code>属性中写的东西</strong>:就是<code>&lt;my-component&gt;</code>这个自定义标签渲染后展现出来的样式，这里渲染为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello Vue component<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello Vue component<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="使用template标签"><a href="#使用template标签" class="headerlink" title="使用template标签"></a>使用template标签</h3><p>在上面这段代码中组件内的内容都被写在<code>template</code>属性中，如果组件中的内容继续增加，一堆的引号和加号来拼接这些字符串简直就是噩梦。所以Vue 引入了<code>template</code>标签（html5定义的，浏览器默认不去解析里面的内容）。<strong><code>&lt;template&gt; 不能用在 &lt;table&gt; 内</code></strong>下面来看看它的使用方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 使用 template 并且添加选择器(只能使用id)--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"myTemp"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Template <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>add ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">        Vue.component(<span class="string">"my-component"</span>, &#123;</div><div class="line">            template:<span class="string">"#myTemp"</span><span class="comment">//对应上面定义的template标签中的选择器</span></div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">new</span> Vue(&#123;</div><div class="line">            el:<span class="string">"#app"</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到在注册组件中，可以<code>template</code>可以使用选择器来获取到上面我们<code>&lt;template&gt;</code>标签中的内容。所以这里应该会被渲染为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Template <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>add ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Template <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>add ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>组件的基础介绍就到这，更多详细内容请移步<a href="http://cn.vuejs.org/guide/" target="_blank" rel="external">官网</a> </p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>刚刚已经对于vue的组件有了一定的了解。现在来结合vue-router，来进行一下动态的切换。</p>
<p>首先是安装，如果使用npm的形式的话，直接运行<code>npm install vue-router --save</code>,就可以看到<code>vue-router</code>，已经被添加到了项目依赖中。直接上<code>ES6</code>的语法来进行引入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">"vue-router"</span>;</div><div class="line">Vue.use(VueRouter);</div></pre></td></tr></table></figure>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>其实这一部分<code>vue-router</code>的<a href="http://vuejs.github.io/vue-router/zh-cn/basic.html" target="_blank" rel="external">中文文档</a>中已经讲的非常详细了。。在这里与它不同的是它用的<code>CommonJS</code>的规范来进行模块安装，而我使用ES6的import，有兴趣自己去看- -。其他的内容我就直接扒下来了。</p>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 使用指令 v-link 进行导航。 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/foo' &#125;"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/bar' &#125;"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 路由外链 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>javascript:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义组件</span></div><div class="line"><span class="keyword">var</span> Foo = Vue.extend(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;p&gt;This is foo!&lt;/p&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">var</span> Bar = Vue.extend(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;p&gt;This is bar!&lt;/p&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 路由器需要一个根组件。</span></div><div class="line"><span class="comment">// 出于演示的目的，这里使用一个空的组件，直接使用 HTML 作为应用的模板</span></div><div class="line"><span class="keyword">var</span> App = Vue.extend(&#123;&#125;)</div><div class="line"><span class="comment">// 创建一个路由器实例</span></div><div class="line"><span class="comment">// 创建实例时可以传入配置参数进行定制，为保持简单，这里使用默认配置</span></div><div class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter()</div><div class="line"><span class="comment">// 定义路由规则</span></div><div class="line"><span class="comment">// 每条路由规则应该映射到一个组件。这里的“组件”可以是一个使用 Vue.extend</span></div><div class="line"><span class="comment">// 创建的组件构造函数，也可以是一个组件选项对象。</span></div><div class="line"><span class="comment">// 稍后我们会讲解嵌套路由</span></div><div class="line">router.map(&#123;</div><div class="line">    <span class="string">'/foo'</span>: &#123;</div><div class="line">        <span class="attr">component</span>: Foo</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/bar'</span>: &#123;</div><div class="line">        <span class="attr">component</span>: Bar</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 现在我们可以启动应用了！</span></div><div class="line"><span class="comment">// 路由器会创建一个 App 实例，并且挂载到选择符 #app 匹配的元素上。</span></div><div class="line">router.start(App, <span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<p>我个人感觉这部分还是很好理解的，官方也给了一个<a href="http://jsfiddle.net/yyx990803/xyu276sa/" target="_blank" rel="external">在线示例应用</a>。很好的展现了它的路由切换。</p>
<p>简单的介绍到这，下面最重要的部分到了，看看如何结合我们定义的<code>.vue</code>单文件组件。</p>
<p>首先来看我们的文件目录结构：</p>
<p><img src="/images/vue-webpack/01-webpack-vuerouter.jpg" alt="01-webpack-vuerouter"></p>
<h3 id="定义路由规则"><a href="#定义路由规则" class="headerlink" title="定义路由规则"></a>定义路由规则</h3><p><strong>最主要是<code>main.js</code></strong>的变化，直接在文件中讲解了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入vue以及vue-router</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">"vue-router"</span>;</div><div class="line">Vue.use(VueRouter);</div><div class="line"><span class="comment">// 引入组件！直接使用es6的语法</span></div><div class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">'./components/app.vue'</span>;</div><div class="line"><span class="keyword">import</span> list <span class="keyword">from</span> <span class="string">'./components/list.vue'</span>;</div><div class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./components/hello.vue'</span>;</div><div class="line"><span class="comment">//开启debug模式</span></div><div class="line">Vue.config.debug = <span class="literal">true</span>;</div><div class="line"><span class="comment">// new Vue(app);//这是上一篇用到的，新建一个vue实例，现在使用vue-router就不需要了。</span></div><div class="line"><span class="comment">// 路由器需要一个根组件。</span></div><div class="line"><span class="keyword">var</span> App = Vue.extend(&#123;&#125;);</div><div class="line"><span class="comment">// 创建一个路由器实例</span></div><div class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter();</div><div class="line"><span class="comment">// 每条路由规则应该映射到一个组件。这里的“组件”可以是一个使用 Vue.extend创建的组件构造函数，也可以是一个组件选项对象。</span></div><div class="line"><span class="comment">// 稍后我们会讲解嵌套路由</span></div><div class="line">router.map(&#123;<span class="comment">//定义路由映射</span></div><div class="line">    <span class="string">'/index'</span>:&#123;<span class="comment">//访问地址</span></div><div class="line">        name:<span class="string">'index'</span>,<span class="comment">//定义路由的名字。方便使用。</span></div><div class="line">        component:index,<span class="comment">//引用的组件名称，对应上面使用`import`导入的组件</span></div><div class="line">        <span class="comment">//component:require("components/app.vue")//还可以直接使用这样的方式也是没问题的。不过会没有import集中引入那么直观</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/list'</span>: &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'list'</span>,</div><div class="line">        <span class="attr">component</span>: list</div><div class="line">    &#125;,</div><div class="line">&#125;);</div><div class="line">router.redirect(&#123;<span class="comment">//定义全局的重定向规则。全局的重定向会在匹配当前路径之前执行。</span></div><div class="line">    <span class="string">'*'</span>:<span class="string">"/index"</span><span class="comment">//重定向任意未匹配路径到/index</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 现在我们可以启动应用了！</span></div><div class="line"><span class="comment">// 路由器会创建一个 App 实例，并且挂载到选择符 #app 匹配的元素上。</span></div><div class="line">router.start(App, <span class="string">'#app'</span>);</div></pre></td></tr></table></figure>
<p>在index.html需要有用于渲染匹配的组件，如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>现在当我们运行 <code>npm start</code> 进入<code>http://localhost:8080/</code>就会自动跳转到<code>http://localhost:8080/#!/index</code>，并且读取里面的内容。</p>
<h3 id="实现路由跳转"><a href="#实现路由跳转" class="headerlink" title="实现路由跳转"></a>实现路由跳转</h3><p>主要抽出<code>app.vue</code>中的内容来讲解，的内容是：(<code>list.vue</code>里面的内容自行设置查看吧)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"golist"</span>&gt;</span>$route.router.go查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'list' &#125;"</span>&gt;</span>v-link查看列表<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'index' &#125;"</span>&gt;</span>回去主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">//这里是官方的写法，默认导出，ES6</span></div><div class="line">        data () &#123; <span class="comment">//ES6，等同于data:function()&#123;&#125;</span></div><div class="line">            <span class="keyword">return</span> &#123;    <span class="comment">//必须使用这样的形式，才能创建出单一的作用域</span></div><div class="line">                name:<span class="string">"guowenfh"</span>,</div><div class="line">                <span class="attr">age</span>:<span class="string">"21"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">methods</span> :&#123;</div><div class="line">            golist () &#123;<span class="comment">//方法，定义路由跳转，注意这里必须使用this，不然报错</span></div><div class="line">                <span class="keyword">this</span>.$route.router.go(&#123;<span class="attr">name</span>:<span class="string">"list"</span>&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 样式自行设置，或者直接看源码就好 --&gt;</span></div></pre></td></tr></table></figure></p>
<p>因为自刷新的缘故，直接切换到浏览器。</p>
<p>点击上面使用的<code>v-link</code>，与<code>router.go</code>的方式都可以跳转到<code>list</code>定义的路由。（<strong>观察浏览器地址栏的变化</strong>）在这里我们使用的<code>{name:&quot;list&quot;}</code>，使用<code>{ path: &#39;/list&#39; }</code>会有同样的效果。</p>
<h2 id="引用Vue组件"><a href="#引用Vue组件" class="headerlink" title="引用Vue组件"></a>引用Vue组件</h2><p>在第一小点里面我们看到了在页面内的组件的使用方法，第二小点中学习到了<code>vue-router</code>的制定路由规则。</p>
<p>看过这两个地方之后，我们把思维发散开来，应该就能触类旁通的想到如何在页面中嵌套加载别的组件了。<br>我们创建一个<code>hello.vue</code> ，里面内容随意。现在我们如果要在<code>app.vue</code>中加载它，那么只需要在<code>app.vue</code>中使用<code>import hello from &quot;./hello.vue&quot;</code>（其实这个达到了使用require两步的效果。引入赋值）。</p>
<p>引入之后，只需要如下注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//其它的就</span></div><div class="line">    components:&#123;</div><div class="line">        hello<span class="comment">//若还有更多的组件，只需要在import的情况下，以逗号分割，继续注册就好</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后在<code>app.vue</code>中添加<code>&lt;hello&gt;&lt;/hello&gt;</code>这一对自定义标签，就可以实现加载<code>hello.vue</code>中的内容。</p>
<p>组件的嵌套也就是这样，很简单的描述完了，但是怎么样去抽离组件，在工作中积累可以复用的组件才是我们真正需要去思考的。</p>
<p>那么先到这，关于组件之间通信的问题，留到以后慢慢了解。</p>
<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>还是刚刚的代码与目录结构，我们已经实现了组件之间的嵌套，但是有时并不希望组件直接就加载进来，而是在用户点击后才展现在页面中，这是就需要使用到路由嵌套。</p>
<p>为了偷懒，这里就直接使用<code>hello.vue</code>。实现嵌套路由主要有以下几步：</p>
<p>第一步：制定嵌套路由规则：</p>
<p>看<code>main.js</code>下面这部分的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">router.map(&#123;</div><div class="line">    <span class="string">'/index'</span>:&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'index'</span>,</div><div class="line">        <span class="attr">component</span>:index,</div><div class="line">        <span class="comment">// 在/index下设置一个子路由</span></div><div class="line">        subRoutes:&#123; </div><div class="line">            <span class="comment">// 当匹配到/index/hello时，会在index的&lt;router-view&gt;内渲染</span></div><div class="line">            <span class="string">'/hello'</span>:&#123;</div><div class="line">                <span class="attr">name</span>:<span class="string">'hello'</span>,<span class="comment">//可有可无，主要是为了方便使用</span></div><div class="line">                <span class="comment">// 一个hello组件</span></div><div class="line">                component:hello</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二步：在组件中添加<code>&lt;router-view&gt;</code></p>
<blockquote>
<p>来自官网的解释：<code>&lt;router-view&gt;</code> 用于渲染匹配的组件，它基于Vue的动态组件系统，所以它继承了一个正常动态组件的很多特性。</p>
</blockquote>
<p>将<code>&lt;router-view&gt;</code>写在<code>app.vue</code>的<code>&lt;template&gt;&lt;/template&gt;</code>标签中。</p>
<p>第三步：写入跳转路径</p>
<p>还是在<code>app.vue</code>中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'index' &#125;"</span>&gt;</span>回去主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 点击这两个标签就会实现页面内的切换效果 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'hello' &#125;"</span>&gt;</span>嵌套的路由<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>，切换到浏览器，点击该<code>嵌套的路由</code>即可让<code>hello.vue</code>中的展现出来，在这里直接使用了<code>v-link</code>来实现跳转（知道为什么要写name了吧。。如果使用path会是这样的<code>{ path: &#39;/index/hello&#39; }</code>- -。 ） ，当然<code>router.go</code>同理。（注意在点击两个不同的文字时，地址栏的变化，以及展现内容的切换）</p>
<p><strong>注意：</strong></p>
<p>在我的源码中是在<code>&lt;style scoped&gt;&lt;/style&gt;</code>标签中定义样式的，请注意<code>scoped</code>的使用，它表示在该<code>style</code>中定义的样式只会在当前的组件中起到效果，而不会去影响全局的css样式。</p>
<p>最简单的理解应该就是：</p>
<p>未写该<code>scoped</code>属性的所有组件中的样式，在经过<code>vue-loader</code>编译之后拥有全局作用域。相当于共用一份<code>css</code>样式表。</p>
<p>而写了该属性的的组件中定义的样式，拥有独立作用域。相当于除去引入了公用的一份<code>css</code>样式表外，但单独拥有一份<code>css</code>的样式表。</p>
<p>好了，先到这。讲的有些凌乱，下次见</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列文章，此系列所有的练习都存在了我的github仓库中&lt;a href=&quot;https://github.com/guowenfh/vue-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-webpack&lt;/a&gt;，在本人有了新的理解
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
      <category term="vue" scheme="http://guowenfh.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（五）加载vue单文件组件</title>
    <link href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/"/>
    <id>http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/</id>
    <published>2016-03-25T03:57:50.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a>，在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<h2 id="需要什么？"><a href="#需要什么？" class="headerlink" title="需要什么？"></a>需要什么？</h2><p>在经过前面的四个练习，相信已经对于<code>webapck</code>有了一定的了解，现在我们就来一个综合案例，进一步加深对于<code>webpack</code>的理解。</p>
<p>首先我们应该思考要解析<code>.vue</code>类型的文件，需要什么样的东西？应该按照什么样的步骤来？我们应该怎么去搭建这个项目？</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="第一步：初始化项目目录"><a href="#第一步：初始化项目目录" class="headerlink" title="第一步：初始化项目目录"></a>第一步：初始化项目目录</h3><p>我们需要创建如下目录及文件夹，最终目录结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- dist <span class="comment">//文件生成目录</span></div><div class="line">    -- <span class="comment">//自动生成</span></div><div class="line">- node_module <span class="comment">//自动安装</span></div><div class="line">    -- ...</div><div class="line">- src <span class="comment">//文件入口</span></div><div class="line">    -- components <span class="comment">//组件存放</span></div><div class="line">        -- app.vue <span class="comment">//主.vue</span></div><div class="line">    -- main.js <span class="comment">//主.js</span></div><div class="line">- index.html <span class="comment">//主.html</span></div><div class="line">- package.json <span class="comment">//npm 配置</span></div><div class="line">- webpack.cofig.js <span class="comment">// webpack配置</span></div></pre></td></tr></table></figure>
<h3 id="第二步：安装项目依赖"><a href="#第二步：安装项目依赖" class="headerlink" title="第二步：安装项目依赖"></a>第二步：安装项目依赖</h3><p>如果你上面没有创建<code>package.json</code>文件的话，可以直接使用<code>npm init</code>来初始化我们的<code>package.json</code>文件的配置。</p>
<p>想要去编译其他的文件比如<code>react</code>，<code>coffce</code>等等，就必须要加载很多对应的<code>loader</code>。要想加载一个<code>.vue</code>文件。当然也是同样的道理。<br>建议用<code>npm install xxx-loader --save-dev</code>这样的命令一条一条的敲。在命令行中，会有提示，可以帮助理解<code>webpack</code>的中的依赖管理关系。我的配置清单如下：<br><strong>在实际项目中，json文件中不能出现注释</strong>，在这里为了方便大家了解里面设置项的含义，就直接使用注释的方式加载后面了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"05-five-vue"</span>, <span class="comment">//项目名称</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>, <span class="comment">//版本</span></div><div class="line">    <span class="string">"description"</span>: <span class="string">"vue+webapck"</span>, <span class="comment">//描述</span></div><div class="line">    <span class="string">"main"</span>: <span class="string">"index.js"</span>, <span class="comment">//主文件</span></div><div class="line">    <span class="string">"scripts"</span>: &#123;</div><div class="line">        <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">        <span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></div><div class="line">    &#125;, <span class="comment">//scripts指定了运行脚本命令的npm命令行缩写，比如这是的start指定了运行npm run start时，所要执行的命令。</span></div><div class="line">    <span class="string">"dependencies"</span>: &#123; <span class="comment">//项目依赖</span></div><div class="line">        <span class="string">"vue"</span>: <span class="string">"^1.0.18"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"devDependencies"</span>: &#123; <span class="comment">//各种各样的loader，用来解析想相应的文件格式。要解析vue并且完成相应的功能，这些基本都是必须的。</span></div><div class="line">        <span class="string">"autoprefixer-loader"</span>: <span class="string">"^2.0.0"</span>,</div><div class="line">        <span class="string">"babel"</span>: <span class="string">"^6.3.13"</span>,</div><div class="line">        <span class="string">"babel-core"</span>: <span class="string">"^6.3.21"</span>,</div><div class="line">        <span class="string">"babel-loader"</span>: <span class="string">"^6.2.0"</span>,</div><div class="line">        <span class="string">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.3.13"</span>,</div><div class="line">        <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.3.13"</span>,</div><div class="line">        <span class="string">"babel-runtime"</span>: <span class="string">"^5.8.34"</span>,</div><div class="line">        <span class="string">"css-loader"</span>: <span class="string">"^0.16.0"</span>,</div><div class="line">        <span class="string">"file-loader"</span>: <span class="string">"^0.8.5"</span>,</div><div class="line">        <span class="string">"html-loader"</span>: <span class="string">"^0.3.0"</span>,</div><div class="line">        <span class="string">"node-sass"</span>: <span class="string">"^3.4.2"</span>,</div><div class="line">        <span class="string">"sass-loader"</span>: <span class="string">"^3.2.0"</span>,</div><div class="line">        <span class="string">"style-loader"</span>: <span class="string">"^0.12.3"</span>,</div><div class="line">        <span class="string">"url-loader"</span>: <span class="string">"^0.5.6"</span>,</div><div class="line">        <span class="string">"vue-html-loader"</span>: <span class="string">"^1.2.0"</span>,</div><div class="line">        <span class="string">"vue-loader"</span>: <span class="string">"^7.2.0"</span>,</div><div class="line">        <span class="string">"webpack"</span>: <span class="string">"^1.12.0"</span>,</div><div class="line">        <span class="string">"webpack-dev-server"</span>: <span class="string">"^1.14.0"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"author"</span>: <span class="string">"guowenfh"</span>, <span class="comment">//作者</span></div><div class="line">    <span class="string">"license"</span>: <span class="string">"MIT"</span>, <span class="comment">//开源协议</span></div><div class="line">    <span class="string">"keywords"</span>: [ <span class="comment">//关键字</span></div><div class="line">        <span class="string">"vue"</span>,</div><div class="line">        <span class="string">"webpack"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想省事的话，直接复制上面的<code>devDependencies</code>,<code>dependencies</code>字段，并且填写到你的<code>package.json</code>文件中。然后运行<code>npm install</code>就会自动安装所有的模块以及依赖。</p>
<h3 id="第三步：配置webpack"><a href="#第三步：配置webpack" class="headerlink" title="第三步：配置webpack"></a>第三步：配置webpack</h3><p>文件已经设置好了，接下来就到了我们关键的一步，配置<code>webpack.config.js</code>,清单如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="comment">// NodeJS中的Path对象，用于处理目录的对象，提高开发效率。</span></div><div class="line"><span class="comment">// 模块导入</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="comment">// 入口文件地址，不需要写完，会自动查找</span></div><div class="line">    entry: <span class="string">'./src/main'</span>,</div><div class="line">    <span class="comment">// 输出</span></div><div class="line">    output: &#123;</div><div class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">'./dist'</span>),</div><div class="line">        <span class="comment">// 文件地址，使用绝对路径形式</span></div><div class="line">        filename: <span class="string">'[name].js'</span>,</div><div class="line">        <span class="comment">//[name]这里是webpack提供的根据路口文件自动生成的名字</span></div><div class="line">        publicPath: <span class="string">'/dist/'</span></div><div class="line">        <span class="comment">// 公共文件生成的地址</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 服务器配置相关，自动刷新!</span></div><div class="line">    devServer: &#123;</div><div class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">hot</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">inline</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">grogress</span>: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 加载器</span></div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        <span class="comment">// 加载器</span></div><div class="line">        loaders: [</div><div class="line">        <span class="comment">// 解析.vue文件</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue'</span> &#125;,</div><div class="line">        <span class="comment">// 转化ES6的语法</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</div><div class="line">        <span class="comment">// 编译css并自动添加css前缀</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css!autoprefixer'</span>&#125;,</div><div class="line">        <span class="comment">//.scss 文件想要编译，scss就需要这些东西！来编译处理</span></div><div class="line">        <span class="comment">//install css-loader style-loader sass-loader node-sass --save-dev</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">loader</span>: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">        <span class="comment">// 图片转化，小于8K自动转化为base64的编码</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;,</div><div class="line">        <span class="comment">//html模板编译？</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(html|tpl)$/</span>, <span class="attr">loader</span>: <span class="string">'html-loader'</span> &#125;,</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// .vue的配置。需要单独出来配置，其实没什么必要--因为我删了也没保错，不过这里就留这把，因为官网文档里是可以有单独的配置的。</span></div><div class="line">    vue: &#123;</div><div class="line">        <span class="attr">loaders</span>: &#123;</div><div class="line">            <span class="attr">css</span>: <span class="string">'style!css!autoprefixer'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 转化成es5的语法</span></div><div class="line">    babel: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>],</div><div class="line">        <span class="attr">plugins</span>: [<span class="string">'transform-runtime'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">        <span class="comment">// require时省略的扩展名，如：require('module') 不需要module.js</span></div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>],</div><div class="line">        <span class="comment">// 别名，可以直接使用别名来代表设定的路径以及其他</span></div><div class="line">        alias: &#123;</div><div class="line">            <span class="attr">filter</span>: path.join(__dirname, <span class="string">'./src/filters'</span>),</div><div class="line">            <span class="attr">components</span>: path.join(__dirname, <span class="string">'./src/components'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 开启source-map，webpack有多种source-map，在官网文档可以查到</span></div><div class="line">    devtool: <span class="string">'eval-source-map'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>请详细查看这里面的设置，我这里都是很简单的配置，在你的项目中，还可以更进一步的对于入口文件和输出文件进行更加深入的定制。（注意：好像<code>node-sass</code>的包有问题，有很多人解析不了<code>sass</code>）</p>
<p>并且在这里生成的css文件还会插到js中，有时我们需要更进一步的把它独立出来，然后在html中引入这时就会用到<code>webpack</code>的插件，在这里先不说（因为我暂时没用到，没有试验过，好像也不麻烦，可以的话下篇再试试）</p>
<h3 id="第四步：编写代码"><a href="#第四步：编写代码" class="headerlink" title="第四步：编写代码"></a>第四步：编写代码</h3><p>接下来就是我们要展示的文件的编写了，我直接把代码贴上来了。</p>
<p>index.html：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-id">#app</span> &#123;</div><div class="line">            <span class="attribute">margin</span>: <span class="number">20px</span> auto;</div><div class="line">            <span class="attribute">width</span>: <span class="number">800px</span>;</div><div class="line">            <span class="attribute">height</span>: <span class="number">600px</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里是main.js的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es6语法：</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"../node_modules/vue/dist/vue.min.js"</span>;<span class="comment">//其实不用写完，会自动查找。可以直接写import Vue from "vue";</span></div><div class="line"><span class="comment">//外部引入别的库都可以用这样的方式，比如jquery等。。</span></div><div class="line"><span class="comment">//引入我们编写的测试用vue文件。</span></div><div class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'./components/app'</span>;</div><div class="line"></div><div class="line">Vue.config.debug = <span class="literal">true</span>;<span class="comment">//开启错误提示</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(app);</div></pre></td></tr></table></figure>
<p>这里是app.vue：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">//es6</span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">        <span class="attr">el</span>:<span class="string">"#app"</span>,</div><div class="line">         <span class="comment">//data:function()&#123;&#125;，下面是es6写法</span></div><div class="line">         data () &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">name</span>:<span class="string">"guowenfh"</span>,</div><div class="line">                <span class="attr">age</span>:<span class="string">"2q1"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"sass"</span>&gt;</span><span class="undefined"></span></div><div class="line">    /*一定要加lang不然无法编译*/</div><div class="line">    /*测试一下对sass的编译*/</div><div class="line">    $qwe:#098;</div><div class="line">    body&#123;</div><div class="line">        background-color: $qwe;</div><div class="line">        h1&#123;</div><div class="line">            background-color: #eee;</div><div class="line">            color: red;</div><div class="line">            transform: translate(10%, 10%);/*测试自动添加前缀*/</div><div class="line">        &#125;</div><div class="line">        h1:hover&#123;</div><div class="line">            height:100px;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        h2&#123;</div><div class="line">            background-color: #999;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="第五步：修改自动刷新设置"><a href="#第五步：修改自动刷新设置" class="headerlink" title="第五步：修改自动刷新设置"></a>第五步：修改自动刷新设置</h3><p>下面再单独的再谈一下关于自动刷新的实现，首先需要说明，在上一篇博客中的自动刷新实现，是有问题的。只能改变css样式，使颜色进行变化。对于html里面的内容改变时，浏览器并不会自动刷新。</p>
<p><strong>注意点一：</strong><br>首先我们看到<code>package.json</code>中<code>scripts</code>字段中的<code>&quot;start&quot;: &quot;webpack-dev-server --inline&quot;</code>。这里如果按照网上的方法在后面再添加上<code>--hot</code>的话，只会对于<code>app.vue</code>中的<code>&lt;style&gt;</code>标签内的css起效果。</p>
<p><strong>注意点二：</strong><br>因为我们没有加<code>--hot</code>，所以在<code>webpack.cofig.js</code>中需要对于<code>devServer</code>进行一些配置，如下：（主要是是<code>hot</code>设置为了false）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">hot</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">inline</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">grogress</span>: <span class="literal">true</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样设置了之后按下保存相当于按下了F5浏览器整个刷新。而不是局部刷新。（如果你实现了局部刷新，并且没有其他问题，那请教教我^_^）</p>
<p><strong>注意点三：</strong></p>
<p>注意<code>package.json</code>的loader安装中的<code>&quot;vue-hot-reload-api&quot;: &quot;^1.2.2&quot;</code>。它有可能是导致你不能自动刷新的凶手(我现在都没搞明白到底该安装，还是取消)</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>步骤都走完了，因为在上面的<code>package.json</code>中已经进行了<code>scripts</code>项的配置。运行<code>npm start</code>，打开<code>localhost:8080</code></p>
<p>可以看到设置的背景色已经出来了,去改变一下背景颜色？data？template？ </p>
<p>看看浏览器会不会自动刷新？</p>
<hr>
<p>如果你按照我的步骤，并且，npm包安装没有错误的话，应该就能成功了。</p>
<p>不行的话，请再仔细对照去看看有什么地方没有编写对吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列文章，此系列所有的练习都存在了我的github仓库中&lt;a href=&quot;https://github.com/guowenfh/vue-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-webpack&lt;/a&gt;，在本人有了新的理解
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
      <category term="vue" scheme="http://guowenfh.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（四）扬帆起航</title>
    <link href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/"/>
    <id>http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/</id>
    <published>2016-03-24T09:28:34.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a>，在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>现在来我们来试试加载图片，首先第一件事情，肯定是安装对应的<code>loader</code>。它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install url-loader --save-dev</div></pre></td></tr></table></figure>
<p>当然你也可以在<code>package.json</code>添加依赖，然后再<code>npm nstall</code>一样的效果。</p>
<p>现在去我们的项目目录中添加img文件夹，添加两张图片，一张大图jpg，一张小图png。</p>
<p>然后在我们的<code>webpack.config.js</code>中添加这段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loaders: [</div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">"style!css"</span> &#125;,</div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">"url-loader?limit=8192"</span> &#125;   <span class="comment">// 添加到这！并且会按照文件大小, 或者转化为 base64, 或者单独作为文件</span></div><div class="line">    <span class="comment">//在大小限制后可以加上&amp;name=./[name].[ext]，会将我们的文件生成在设定的文件夹下。</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>在html中添加：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/logo.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qwe"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"asd"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在我们的css中添加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*记得写宽高。。*/</span></div><div class="line"><span class="selector-id">#qwe</span>&#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/logo.png);<span class="comment">/*3.2k*/</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#asd</span>&#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/5.jpg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续运行<code>webpack</code>如果正确的话，打开我们的浏览器，就可以看到我们正确的图片显示。</p>
<p>如果不正确，请运行<code>npm install file-loader -D</code>，再进行尝试。</p>
<p>现在我们打开浏览器的调试工具，可以看到小于8K的 <strong>背景图片</strong> 图片已经被转化成了base64的编码，而大于8k的图片则并没有转化（<strong>注意它的地址的变化！</strong>）。<br>直接使用img导入的图也并没有进行base64的转化。</p>
<h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><p>当项目逐渐变大，<code>webpack</code>的编译时间会变长，可以通过参数让编译的输出内容带有 <strong>进度</strong> 和 <strong>颜色</strong> 。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --progress --colors</div></pre></td></tr></table></figure>
<p>下面还有一些其他常用的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">webpack <span class="comment">#最基本的启动webpack命令</span></div><div class="line">webpack -w <span class="comment">#提供watch方法，实时进行打包更新</span></div><div class="line">webpack -p <span class="comment">#对打包后的文件进行压缩</span></div><div class="line">webpack <span class="_">-d</span> <span class="comment">#提供SourceMaps，方便调试</span></div><div class="line">webpack --colors <span class="comment">#输出结果带彩色，比如：会用红色显示耗时较长的步骤</span></div><div class="line">webpack --profile <span class="comment">#输出性能数据，可以看到每一步的耗时</span></div><div class="line">webpack --display-modules <span class="comment">#默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</span></div></pre></td></tr></table></figure>
<p>我们已经把webpack的内容了解了一部分了，那么在生产环境中，我不想每一次进行改变，都去命令行中运行我们的<code>webpack</code>的命令，我们应该怎么样实现改变后自动更新呢？</p>
<p>webpack 为我们提供了一个<code>webpack --watch</code>，他会启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。</p>
<p>去运行这个命令试试吧！！</p>
<p>在我们改变代码之后，命令行中可以看到直接就自动编译了，但是显然不够智能，还需要我们手动去刷新浏览器，（其实用<code>liveload</code>hack成自动刷新！）。</p>
<p>我反正不能忍，还要手动刷新浏览器。所以使用<code>webpack-dev-server</code>会是一个更好的办法！</p>
<p>它将在<code>localhost:8080</code>启动一个express静态资源web服务器，并且会以监听模式自动运行<code>webpack</code>，在浏览器打开<code>http://localhost:8080/</code>或 <code>http://localhost:8080/webpack-dev-server/</code> 可以浏览项目中的页面和编译后的资源输出，并且通过一个<code>socket.io</code>服务实时监听它们的变化并自动刷新页面。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装</span></div><div class="line">npm install webpack-dev-server -g</div><div class="line"></div><div class="line"><span class="comment"># 运行</span></div><div class="line">webpack-dev-server</div></pre></td></tr></table></figure>
<p>我们来试试使用vue能配合webpack能不能实现自动刷新。(有关vuejs的知识，大家可以可以先自行上<a href="http://cn.vuejs.org/guide/" target="_blank" rel="external">官网查看</a>，我在接下来可能也会一步一步的把vue的例子全部敲一遍，再放到github上来让点评)</p>
<p>首先运行<code>npm install vue -save</code>将vue添加到我们的项目依赖中去。</p>
<p>首先在我们的<code>entry.js</code>这个入口文件中进行添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import Vue form ("vue") //如果你安装了babel-loader的话，可以直接使用ES6的语法</span></div><div class="line"><span class="keyword">var</span> Vue =<span class="built_in">require</span>(<span class="string">"vue"</span>);</div><div class="line">    <span class="keyword">new</span> Vue(&#123;</div><div class="line">        <span class="attr">el</span>: <span class="string">"body"</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">message</span>: <span class="string">"hello vue.js"</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>同样在<code>index.html</code>中添加<code></code>来响应vue的数据绑定。</p>
<p>运行<code>webpack-dev-server</code>。去浏览器查看试试效果吧！任意改变<code>message</code>中的值，可以看到浏览器会自动刷新。并且将改变的值展示在眼前。（有可能只在<code>http://localhost:8080/webpack-dev-server/</code>才会自动刷新）</p>
<p><strong>这里其实并没有完全对，不够全面，可能只能响应css的改变。将在下一篇继续调整该配置</strong></p>
<p>自动刷新都配好了。下面我们就来试试怎么加载vue的文件，来实现单文件组件！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列文章，此系列所有的练习都存在了我的github仓库中&lt;a href=&quot;https://github.com/guowenfh/vue-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-webpack&lt;/a&gt;，在本人有了新的理解
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
      <category term="vue" scheme="http://guowenfh.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（三）webpack.config入门</title>
    <link href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/"/>
    <id>http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/</id>
    <published>2016-03-24T09:28:14.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a>，在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<p>在上面我们已经尝试过了两种对于loader的使用方式，无论是在<code>require</code>的时候编写我们<code>loader</code>的前缀，还是在我们的命令行中进根据扩展名来自动绑定我们的<code>loader</code>，显然都不够自动化，在需要编译的语言继续增加的情况下，显然会是一个噩梦。<br>所以webapck实际上为我们提供了一个简单的方法，下面就一起来看看。</p>
<h2 id="了解webpack配置"><a href="#了解webpack配置" class="headerlink" title="了解webpack配置"></a>了解webpack配置</h2><p>Webpack在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的<code>webpack.config.js</code>文件，这个文件是一个 <code>node.js</code> 模块，返回一个 <code>json</code> 格式的配置信息对象，或者通过 <code>--config</code> 选项来指定配置文件。</p>
<p>所以现在我们就来新建一个<code>webpack.config.js</code>，在里面填写进下面的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: [<span class="string">"./entry.js"</span>],</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">path</span>: __dirname,</div><div class="line">        <span class="attr">filename</span>: <span class="string">"bundle.js"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">"style!css"</span></div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在仅仅需要运行:<code>webpack</code>，如果你的配置没有问题的话，可以在命令行中看到正确的输出，因为这个命令会自动在当前目录中查找<code>webpack.config.js</code>的配置文件，并按照里面定义的规则来进行执行。</p>
<p>去修改我们的css文件吧，感受一下它的便利。</p>
<p>上面我们仅仅是使用了这个配置文件，我们肯定想在实际的工作环境中，自我对于项目进行针对性的配置。下面我们就先来简单的了解一下里面参数的意义：</p>
<ul>
<li><code>entry</code>：指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。 当然如果你只有一个入口的话，也可以直接使用双引号<code>&quot;./entry.js&quot;</code></li>
<li><code>output</code>：配置打包结果，<code>path</code>定义了输出的文件夹，filename则定义了打包结果文件的名称</li>
<li><code>module</code>：定义了对模块的处理逻辑，这里可以用<code>loaders</code>定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的<code>loader</code>对文件进行处理，这正是<code>webpack</code>强大的原因。</li>
</ul>
<p>在这里仅仅能做一些很简单的介绍，如果想要真正做到在项目中的实际应用，还需要大量的练习与尝试。在此暂时不做过多的探究。等真正用到了再记录下来。</p>
<h3 id="了解webpack插件"><a href="#了解webpack插件" class="headerlink" title="了解webpack插件"></a>了解webpack插件</h3><p>下面就来看看<code>webpack</code>中的插件：</p>
<p>插件可以完成更多loader不能完成的功能。插件的使用一般是在<code>webpack.config.js</code>中的<code>plugins</code> 选项中指定。</p>
<p><code>Webpack</code>本身内置了一些常用的插件，还可以通过npm安装第三方插件。</p>
<p>接下来，我们从一个最简单的，用来给输出的文件头部添加注释信息<code>BannerPlugin</code>的内置插件来实践插件的配置和运行。</p>
<p>修改<code>webpack.config.js，</code>添加 plugins配置项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);<span class="comment">//必须引入</span></div><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">&#125;,</div><div class="line"><span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> Webpack.BannerPlugin(<span class="string">"这里是打包文件头部注释！"</span>)<span class="comment">//注意这是一个数组..</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>运行正确的话应该是这样的，打开<code>bundle.js</code>，会发现在文件头部已经有了我们添加的注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*! 这里是打包文件头部注释 */</span></div><div class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></div><div class="line"><span class="comment">/******/</span>    <span class="comment">// The module cache</span></div><div class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> installedModules = &#123;&#125;;</div><div class="line">        <span class="comment">/***  省略 ***/</span></div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<p>最简单的插件使用方式就是这样的了，就如上面一样的，平淡无奇。</p>
<p>如果看到了这里，相信你对于<code>webpack</code>的最基本的了解应该就差不多了，下面正式进入实战的阶段，来看看我们的一些<code>loader</code>到底是怎么样使用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列文章，此系列所有的练习都存在了我的github仓库中&lt;a href=&quot;https://github.com/guowenfh/vue-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-webpack&lt;/a&gt;，在本人有了新的理解
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（二）loader入门</title>
    <link href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/"/>
    <id>http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/</id>
    <published>2016-03-24T09:28:00.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a> 在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在上一篇博客中我们已经成功的把简单的事情变得复杂了，把我们的只有几行代码的两个文件<code>first.js</code>、<code>entry.js</code>使用webpack进行文件打包生成了<code>bundle.js</code>。</p>
<p><code>Webpack</code> 能做的就是这样，只能处理 JavaScript 模块。</p>
<p>当然它如果能做的仅仅是这样，那它也就不可能这么火了=_=。所以它可以通过引入其他的<code>loader</code>，进而可以处理其它类型的文件。</p>
<h2 id="loader介绍"><a href="#loader介绍" class="headerlink" title="loader介绍"></a>loader介绍</h2><p><code>Loader</code>可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过require来加载任何类型的模块或文件，比如<code>VUE</code>、<code>JSX</code>、<code>SASS</code> 或图片。</p>
<p>先来看看 loader 有哪些特性？(网上复制的，不喜欢可以跳过。<a href="http://www.hubwiz.com/class/5670d0a77e7d40946afc5e65" target="_blank" rel="external">地址</a>)</p>
<ul>
<li><code>Loader</code>可以通过管道方式链式调用，每个<code>loader</code>可以把资源转换成任意格式并传递给下一个<code>loader</code>，但是最后一个<code>loader</code>必须返回JavaScript。</li>
<li><code>Loader</code>可以同步或异步执行。</li>
<li><code>Loader</code>运行在node.js环境中，所以可以做任何可能的事情。</li>
<li><code>Loader</code>可以接受参数，以此来传递配置项给<code>loader</code>。</li>
<li><code>Loader</code>可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。</li>
<li><code>Loader</code>可以通过npm发布和安装。</li>
<li>除了通过<code>package.json</code>的<code>main</code>指定，通常的模块也可以导出一个<code>loader</code>来使用。</li>
<li><code>Loader</code>可以访问配置。</li>
<li>插件可以让<code>loader</code>拥有更多特性。</li>
<li><code>Loader</code>可以分发出附加的任意文件。</li>
</ul>
<h2 id="loader使用"><a href="#loader使用" class="headerlink" title="loader使用"></a>loader使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据上面说的<code>loader</code>的知识，就这样编译是肯定不行的，所以我们安装用来读取css文件的<code>css-loader</code>，再用 <code>style-loader</code> 把它插入到页面中。</p>
<p>在命令行中输入：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>在<code>package.json</code>中，主要是<code>devDependencies</code>这个字段有了改变：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">    "css-loader": "^0.23.1",</div><div class="line">    "style-loader": "^0.13.0",</div><div class="line">    "webpack": "^1.12.2"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然你可以用一个更加方便的方式进行安装，可以直接在<code>package.json</code>中，添加相应的依赖（如上面的代码），之后的命令行中运行<code>npm intall</code>，它会自动帮我们安装相应的依赖。</p>
<p>安装完毕。</p>
<h3 id="加载-CSS-文件"><a href="#加载-CSS-文件" class="headerlink" title="加载 CSS 文件"></a>加载 CSS 文件</h3><p>还是上一篇博客中的文件，来添加一个css文件。<code>style.css</code>,在里面添加</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">    <span class="attribute">background</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改我们的<code>entry.js</code>，原文件不变，添加<code>require(&quot;!style!css!./style.css&quot;);</code>,用来引入我们的css文件。</p>
<p>我们继续编译:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js bundle.js</div></pre></td></tr></table></figure>
<p>完成后，刷新我们的页面，背景颜色是不是已经变成了红色了呢？</p>
<h3 id="扩展名自动绑定loader"><a href="#扩展名自动绑定loader" class="headerlink" title="扩展名自动绑定loader"></a>扩展名自动绑定loader</h3><p>这就是我们的<code>loader</code>的使用方式了。如果每次 <code>require</code> CSS 文件的时候都要写 <code>loader</code> 前缀<code>!style!css!</code>这样的东西，显然是一件很麻烦的事情。我们需要它可以根据模块类型（扩展名）来自动绑定需要的 <code>loader</code>。</p>
<p>来看看更简便的方式，将 <code>entry.js</code> 中的 <code>require(&quot;!style!css!./style.css&quot;)</code>修改为<code>require(&quot;./style.css&quot;)</code>，可以改变一个背景颜色让你更明显的查看到变化！然后执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js bundle.js --module-bind <span class="string">"css=style!css"</span></div></pre></td></tr></table></figure>
<p>。。</p>
<p>。。。</p>
<p>没成功对吧!<br>因为<code>!</code>在命令行中具有特殊的含义，所以我们需要对它进行转义操作。再来试试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack ./entry.js bundle.js --module-bind <span class="string">"css=style\!css"</span></div></pre></td></tr></table></figure>
<p>成功的话，应该能再次看到背景的变化。</p>
<p>虽然这样可以将多个css文件进行编译打包，但是总感觉很是繁琐，我不想每次都运行那么一长串的命令怎么办？继续向下走吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列文章，此系列所有的练习都存在了我的github仓库中&lt;a href=&quot;https://github.com/guowenfh/vue-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-webpack&lt;/a&gt; 在本人有了新的理解
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入坑之旅（一）不是开始的开始</title>
    <link href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/"/>
    <id>http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/</id>
    <published>2016-03-24T09:05:58.000Z</published>
    <updated>2016-11-26T16:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近学习框架，选择了vue，然后接触到了vue中的单文件组件，官方推荐使用 Webpack + vue-loader构建这些单文件 Vue 组件，于是就开始了webpack的入坑之旅。<br>因为原来没有用过任何的构建工具与模块化工具，所以本系列会十分的基础。并且可能有很多不正确的地方，希望大家谅解，并指出错误帮助改进。谢谢！</p>
</blockquote>
<p>这是一系列文章，此系列所有的练习都存在了我的github仓库中<a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="external">vue-webpack</a>，在本人有了新的理解与认识之后,会对文章有不定时的更正与更新。下面是目前完成的列表：</p>
<ul>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-01-base/">webpack入坑之旅（一）不是开始的开始</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-02-deploy/">webpack入坑之旅（二）loader入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-03-config/">webpack入坑之旅（三）webpack.config入门</a></li>
<li><a href="http://guowenfh.github.io/2016/03/24/vue-webpack-04-custom/">webpack入坑之旅（四）扬帆起航</a></li>
<li><a href="http://guowenfh.github.io/2016/03/25/vue-webpack-05-vue/">webpack入坑之旅（五）加载vue单文件组件</a> </li>
<li><a href="http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/">webpack入坑之旅（六）配合vue-router实现SPA</a></li>
</ul>
<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><blockquote>
<p>其实不是特别想写这个东西，但貌似所有的教程都有这个。随便写两句吧。可以直接跳过。 </p>
</blockquote>
<p>Webpack 是德国开发者 Tobias Koppers 开发的模块加载器兼打包工具，在webpack中，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl。<br>对应各种不同文件类型的资源, Webpack 有对应的模块 loader比如vue用的是<code>vue-loader</code>当然这是后话，在后面我们再来说。</p>
<p>请看下图：<br><img src="/images/vue-webpack/00-webpack-base.png" alt="webpack"></p>
<p>官网查看：<a href="https://github.com/webpack/webpack" target="_blank" rel="external">https://github.com/webpack/webpack</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>前提：因为webpack是一个基于node的项目，所以首先需要确保你的电脑里面已经安装了<code>node.js</code>，以及<code>npm</code>。在这里我使用的版本是：<code>node：v5.8.0  ，npm：3.7.3</code>,若是版本问题，请更新到最新版。<br>若是有出现npm安装过慢的情况，可以使用<a href="https://github.com/Pana/nrm" target="_blank" rel="external">nrm</a>这个项目来进行npm源地址的切换。</p>
<p>首先我们直接进行全局的安装，运行如下命令：<code>npm install webpack -g</code>，可能需要一点时间。</p>
<p>安装成功后，在命令行输入<code>webpack -h</code>即可查看当前安装的版本信息。以及可以使用的指令。   </p>
<p>当然，我们都应该将webapck安装到当前的项目依赖中，此时就可以使用项目的本这样就可以使用项目本地版本的 Webpack。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 确保已经进入项目目录</span></div><div class="line"><span class="comment"># 确定已经有 package.json，没有就通过</span></div><div class="line">npm init </div><div class="line"><span class="comment"># 创建，直接一路回车就好，后面再来详细说里面的内容。</span></div><div class="line"><span class="comment"># 安装 webpack 依赖</span></div><div class="line"></div><div class="line">npm install webpack --save-dev</div><div class="line"><span class="comment"># 简单的写法：-_-,缩写形式 </span></div><div class="line">npm i webpack -D</div><div class="line"><span class="comment"># –save：模块名将被添加到dependencies，可以简化为参数-S。</span></div><div class="line"><span class="comment"># –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。</span></div></pre></td></tr></table></figure>
<p>安装好之后我们的<code>package.json</code>的目录应该是这样的：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"first-demo"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">"this is my first-demo"</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"author"</span>: <span class="string">"guowenfh"</span>,</div><div class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;&#125;,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"webpack"</span>: <span class="string">"^1.12.14"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然环境都已经安装好了，那么我们就开始来用webpack进行我们的第一个打包运行程序吧！</p>
<p>首先创建一个静态页面 <code>index.html</code> 和一个 JS 入口文件 <code>entry.js</code>,（这里你想用什么名字都可以，只需要在打包的时候读取文件为该名字就好，不过，到时候就知道这个名字的含义啦！）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 注意这里引入的不是我们创建的文件，而是用webpack生成的文件 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*** entry.js ***/</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML=<span class="string">"这是我第一个打包成功的程序"</span>;</div></pre></td></tr></table></figure>
<p>文件都已经创建成功了，那么就开始我们的打包吧！</p>
<p><code>webpack entry.js bundle.js</code></p>
<p>在浏览器中打开<code>index.html</code>，就能看到我们设置的文字啦！：<strong>这是我第一个打包成功的程序</strong></p>
<p>这么简单的功能直接在html中引入不就好了吗？确实是这样的，不过我们这才刚刚开始嘛，不要急。</p>
<p>下面我们再来增加一个文件，名为<code>first.js</code>内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h2= <span class="built_in">document</span>.createElement(<span class="string">"h2"</span>)</div><div class="line">h2.innerHTML=<span class="string">"不是吧，那么快第二个打包程序啦！"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(h2);</div></pre></td></tr></table></figure>
<p>更改 <code>entry.js</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML=<span class="string">"这是我第一个打包成功的程序"</span>;</div><div class="line"><span class="comment">//添加</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"./first.js"</span>);</div></pre></td></tr></table></figure>
<p>再来进行一次重复的工作，再打包一次。<code>webpack entry.js bundle.js</code>，如果成功，打包过程会显示日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Hash: b1cfe7ff9d75ce235dc9</div><div class="line">Version: webpack 1.12.14</div><div class="line">Time: 54ms</div><div class="line">    Asset     Size  Chunks             Chunk Names</div><div class="line">bundle.js  1.82 kB       0  [emitted]  main</div><div class="line">   [0] ./entry.js 208 bytes &#123;0&#125; [built]</div><div class="line">   [1] ./first.js 145 bytes &#123;0&#125; [built]</div></pre></td></tr></table></figure>
<p><code>Webpack</code> 会分析入口文件，<strong>解析包含依赖关系的各个文件</strong>。这些文件（模块）都打包到 <code>bundle.js</code> 。<code>Webpack</code> 会给每个模块分配一个唯一的 <code>id</code> 并通过这个 <code>id</code> 索引和访问模块。在页面启动时，会先执行 <code>entry.js</code> 中的代码，其它模块会在运行 <code>require</code> 的时候再执行。</p>
<p>刷新浏览器，可以发现我们的刚刚的代码已经生效，又有了新的文字出现。</p>
<p>好吧，我知道这么简单的你们不屑于看，等下我们升个级。</p>
<blockquote>
<p>下面是参考文档，也相当于一个汇总吧，有很多我还没实践到，还是可以多看看，好文章应该贴出来</p>
</blockquote>
<ul>
<li><a href="http://www.hubwiz.com/course/5670d0a77e7d40946afc5e65/" target="_blank" rel="external">webpack入门 - 汇智网</a></li>
<li><a href="https://segmentfault.com/a/1190000002552008" target="_blank" rel="external">Webpack 怎么用</a></li>
<li><a href="https://segmentfault.com/a/1190000002551952" target="_blank" rel="external">Webpack 入门指迷</a></li>
<li><a href="https://github.com/vikingmute/webpack-for-fools/blob/master/entries/chapter-1.md" target="_blank" rel="external">Webpack傻瓜式指南（一）</a></li>
<li><a href="https://github.com/vikingmute/webpack-for-fools/blob/master/entries/chapter-2.md" target="_blank" rel="external">Webpack傻瓜式指南（二）</a></li>
<li><a href="http://jiongks.name/blog/just-vue/" target="_blank" rel="external">Vue + webpack 项目实践</a></li>
<li><a href="http://www.w3ctech.com/topic/1557" target="_blank" rel="external">webpack 入门及实践</a></li>
<li><a href="http://javascript.ruanyifeng.com/#nodejs" target="_blank" rel="external">JavaScript 标准参考教程（alpha）–Node.js</a></li>
<li><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">应该是最好懂的Webpack教程—阮一峰</a> 还没敲呢，应该全部敲一遍的。</li>
<li><a href="http://www.h-simon.com/42/" target="_blank" rel="external">webpack常用配置总结</a></li>
<li><a href="https://segmentfault.com/a/1190000004505747" target="_blank" rel="external">Express结合Webpack的全栈自动刷新</a></li>
<li><a href="http://cn.vuejs.org/guide/" target="_blank" rel="external">Vue.js官方教程</a></li>
<li><a href="http://vuejs.github.io/vue-router/zh-cn/" target="_blank" rel="external">vue-router文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习框架，选择了vue，然后接触到了vue中的单文件组件，官方推荐使用 Webpack + vue-loader构建这些单文件 Vue 组件，于是就开始了webpack的入坑之旅。&lt;br&gt;因为原来没有用过任何的构建工具与模块化工具，所以本系列会
    
    </summary>
    
      <category term="前端框架" scheme="http://guowenfh.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="webpack" scheme="http://guowenfh.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap入门笔记之（六）其它内置组件：进度条、列表组、面板等</title>
    <link href="http://guowenfh.github.io/2016/03/01/Bootstrap-06-other-more/"/>
    <id>http://guowenfh.github.io/2016/03/01/Bootstrap-06-other-more/</id>
    <published>2016-02-29T17:41:42.000Z</published>
    <updated>2016-09-11T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>博客之外</p>
<p>只剩最后一天，二月份就结束了。距离上一篇博客已经有着整整一个月的时间，这一个月的时间，感觉技术上的成长又被搁置了，没有了之前闭关学习的心无旁骛，那段时间成长真的飞快。<br>在家喝酒，玩耍，到现在实习入职了一个星期，整整一个月时间，学习效率都十分的低，也可以说基本没学到什么新东西。今天是2月最后一天，不能再这样下去，好了懊恼的时间，不能太多，应该着眼当下，现在是2016-02-29 21:40，开始把bootstrap入门理论基础部分完结了吧，下一步就该进入一个新的阶段了！我将一直前行，加油！</p>
</blockquote>
<hr>
<h2 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h2><p>其实在我们日常使用的网页中，随处都可以看到有缩略图的存在，比如淘宝的商品列表，慕课网上的课程列表等等，Bootstrap自然不会放过那么常见效果，它将这样的效果独立成为了一个模块组件，使用<code>.thumbnail</code>样式类，Boostrap缩略图的默认设计仅需最少的标签就能展示带链接的图片。</p>
<p>我们需要配合Bootstrap的栅格系统来达到一个不错的显示效果。在Bootstrap中文网中，我们可以看到这样的示例代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-md-3"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- 此处应对图片做一些样式设置height: 180px;width: 100%; display: block;等 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        ...</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们将上面代码中的列复制3份，改变浏览器的大小，我可以看到因为栅格系统的存在，我们的缩略图已经变成了响应式的。这是栅格系统起到的效果那么<code>.thumbnail</code>又起到了什么效果呢？<br>我们可以看到图片周围有了一圈边框，并且在边框与图片之间有着4px的padding，除此之外bootstrap还人性化的为我们的缩略图效果提供了hover效果。</p>
<p><strong>添加标题、描述内容、按钮</strong></p>
<p>我们当然不可能仅仅只展示一张可点击的图片就完了，我们时常还会配上相关的说明文字以及一些按钮等等。在已有的缩略图的基础上，我们需要使用<code>.caption</code>容器，并且在这个容器中放置其它的内容，来达到统一的显示效果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 添加到上面代码中的.thumbnail容器内，a标签后 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"caption"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>说明文字<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是说明文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-info"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>看看效果吧：</p>
<p><img src="/images/Bootstrap/06-thumbnail.jpg" alt="缩略图展示"></p>
<h2 id="警示框"><a href="#警示框" class="headerlink" title="警示框"></a>警示框</h2><p>其实在我们的网页中，总是避免不了各种的提示信息，比如我们的登陆界面中，总是避免不了输入错误的情况，就需要使用警示框来提示用户错误信息。Bootstrap为我们提供了一组这样的样式类。</p>
<p>Bootstrap使用<code>.alert</code>来控制警示框的大小边距等样式，然后再用：成功：<code>.alert-success</code>、信息：<code>.alert-info</code>、警告：<code>.alert-warning</code>和错误：<code>.alert-danger</code>、这样的一组样式类,来表示不同的情景颜色。   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-success"</span> <span class="attr">role</span>=<span class="string">"alert"</span>&gt;</span>恭喜您操作成功！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- ...等等 --&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/Bootstrap/06-alert.jpg" alt="缩略图展示"></p>
<p>关闭</p>
<p>除了展示效果之外，如果你还引入了Bootstrap的js文件。那么我们的还可以为我们的警示框非常简单的创造一些交互效果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-success alert-dismissable"</span>&gt;</span></div><div class="line">    success操作成功</div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"alert"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-remove"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到效果如下：（点击后面的icon便可以关闭该提示信息）</p>
<p><img src="/images/Bootstrap/06-alert-close.jpg" alt="缩略图交互"></p>
<p>那么好的效果，在实现的时候需要注意一些什么呢？主要有三个步骤：</p>
<ol>
<li>在普通的警示框<code>.alert</code>的基础上，添加<code>。alert-dismissable</code>类</li>
<li>在button标签中加入<code>close</code>类，实现警示框<strong>关闭按钮</strong>的样式（我在上面使用了Bootstrap自带的icon图标来实现关闭按钮）</li>
<li>在关闭按钮上添加自定义属性<code>data-dismiss=&quot;alert&quot;</code>（Bootstrap中是通过这样的自定义属性，再使用JS检测来实现关闭效果的）</li>
</ol>
<p><strong>警示框的链接</strong></p>
<p>有时我警示框中除了错误信息之外，还会加入一个链接地址，以便于用户在在新的页面中查找问题去处理他的错误。</p>
<p>Bootstrap仅仅使用了一个<code>.alert-link</code>的类就实现了这样的效果，主要是对于链接样式的<strong>高亮显示</strong>、<strong>加粗</strong>，并且<strong>颜色相应加深</strong>。（除此之外在hover上去后有下划线）</p>
<h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><p>Bootstrap框架对于进度条提供了一个基本样式，一个100%宽度的背景色，然后一个子容器高亮，表示完成进度。其实制作这样进度条非常容易，一般使用两个容器，外容器具有一定的宽度，设置一个背景色，他的子元素设置一个宽度（父容器的宽度比例值<code>如60%</code>），同时设置一个高亮的背景色。</p>
<p>Bootstrap也是这样实现的，外层容器使用<code>.progress</code>类，子容器使用<code>.progress-bar</code>类（别忘记设置宽度）如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress-bar"</span> <span class="attr">style</span>=<span class="string">"width:80%"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同样它也提供了四个不同的情景颜色。<code>.progress-bar-info</code>..等，添加到<strong>子容器</strong>原有的类后即可</p>
<p>除了色彩，还可以使进度条的变为条纹的，只需要将<code>progress-striped</code>添加到原有的<strong>父容器</strong>类后，它同样具有彩色效果。更进一步的是，若在其后再添加一个<code>.active</code>类，可以实现动态的条纹进度条。（必须两个同时使用，使用css3动画实现）我们来试试：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress progress-striped active"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress-bar progress-bar-danger"</span> <span class="attr">style</span>=<span class="string">"width:80%"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- .... --&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/Bootstrap/06-progress-striped.jpg" alt="条纹进度条"></p>
<p>我们还可以在一个进度条内，将不同状态的进度条放置在一起，水平排列，形成叠加进度条，这个就自己试试吧！^_^</p>
<p><strong>带标签的显示条</strong><br>使用很简单，只需要在子容器中添加相应的数字就可以了，不过下面这段代码会有什么效果呢？不妨也自己去试试吧！(在源码中搜索<code>aria-valuenow=&quot;0&quot;</code>可看到原因)</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"progress"</span>&gt;</div><div class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"progress-bar"</span> role=<span class="string">"progressbar"</span> aria-valuenow=<span class="string">"0"</span> aria-valuemin=<span class="string">"0"</span> aria-valuemax=<span class="string">"100"</span>&gt;<span class="number">0</span>%&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="媒体对象"><a href="#媒体对象" class="headerlink" title="媒体对象"></a>媒体对象</h2><p>媒体对象一般包括以下几个部分：</p>
<ol>
<li>媒体对像的容器：常使用<code>.media</code>类名表示，用来容纳媒体对象的所有内容</li>
<li>媒体对像的对象：常使用<code>.media-object</code>表示，就是媒体对象中的对象，常常是图片</li>
<li>媒体对象的主体：常使用<code>.media-body</code>表示，就是媒体对像中的主体内容，可以是任何元素，常常是图片侧边内容</li>
<li>媒体对象的标题：常使用<code>.media-heading</code>表示，就是用来描述对象的一个标题，此部分可选</li>
<li><code>.pull-left</code>或者<code>.pull-right</code>来控制媒体对象中的对象浮动方式。(如图片在左或者在右)</li>
</ol>
<p>那么我们可以看到的结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"pull-left"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"media-object"</span> <span class="attr">src</span>=<span class="string">".."</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media-body"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"media-heading"</span>&gt;</span>Bootstrap<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认样式的媒体对象组件允许在一个内容块的左边或右边展示一个多媒体内容（图像、视频、音频）。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以实现最普通的图片在左，标题与介绍文字在右的媒体对象组。</p>
<p>我们在论坛中常常能看到和Bootstrap中文官网媒体对象组模块类似的阶梯状媒体对象，它是怎么实现的呢？<br>其实很简单，我们只需要在上一级的<code>.media-body</code>容器最后添加新的额媒体对象容器<code>.media</code>就可以实现这样的阶梯效果</p>
<p><img src="/images/Bootstrap/06-media.jpg" alt="媒体对象"></p>
<p>除了这样的阶梯形式，我们还可以在论坛评论系统中看到，评论是平铺着下来的，也就是媒体对象列表。</p>
<p>我们只需要将原来的<code>.media</code>放在<code>.media-list</code>容器中就可以实现，不过既然都说了是列表，那我们还是直接使用ul&gt;li的排列方式吧:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"media-list"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"media"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"media"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"media"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Bootstrap同样帮我们清除了，媒体对象列表中的ul&gt;li的默认样式，使展示更急美观</p>
<h2 id="列表组"><a href="#列表组" class="headerlink" title="列表组"></a>列表组</h2><p>列表组是Bootstrap框架新增的一个组件，可以用来制作列表清单、垂直导航等效果，也可以配合其他的组件制作出更漂亮的组件。它主要包括两个部分：</p>
<ol>
<li><code>.list-group</code>：列表组容器，<strong>常用的是ul元素</strong>，当然也可以是ol或者div元素</li>
<li><code>.list-group-item</code>：列表项，<strong>常用的是li元素</strong>，当然也可以是div元素</li>
</ol>
<p>如：</p>
<h3 id="带徽章的列表组"><a href="#带徽章的列表组" class="headerlink" title="带徽章的列表组"></a>带徽章的列表组</h3><p>带徽章的列表组其实就是将Bootstrap框架中的徽章组件和基础列表组结合在一起的一个效果。具体做法很简单，只需要在<code>.list-group-item</code>中添加徽章组件<code>.badge</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span>玩转Bootstrap  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span>基础Bootstrap的网页开发  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge"</span>&gt;</span>12<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以实现笑效果如下：</p>
<p><img src="/images/Bootstrap/06-list-badge.jpg" alt="带徽章的列表"></p>
<p>如果在列表组中，我们希望列表项是链接的话，Bootstrap为我们提供了两种方案：</p>
<ol>
<li>直接将链接置于li<code>.list-group-item</code>容器内，它会有链接下划线的存在</li>
<li>将ul.list-group&gt;li.list-group-item的结构换成div.list-group&gt;a.list-group-item，此时与默认的列表组显示无异(emmet会吧？那就能理解我的代码的意思…)</li>
</ol>
<h3 id="自定义列表组"><a href="#自定义列表组" class="headerlink" title="自定义列表组"></a>自定义列表组</h3><p>除了上面默认的列表组之外，为了更清晰的展示内容，Bootstrap实现了自定义列表组，主要是新增了两个类：</p>
<ol>
<li><code>.list-group-item-heading</code>：用来定义列表项头部样式</li>
<li><code>.list-group-item-text</code>：用来定义列表项主要内容</li>
</ol>
<p>结构如下编写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"##"</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"list-group-item-heading"</span>&gt;</span>图解CSS3<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"list-group-item-text"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"##"</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"list-group-item-heading"</span>&gt;</span>Sass中国<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"list-group-item-text"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="列表项的状态设置"><a href="#列表项的状态设置" class="headerlink" title="列表项的状态设置"></a>列表项的状态设置</h3><p>和其他的组件一样，列表组也两个状态效果：</p>
<ul>
<li><code>.active</code>：表示当前状态</li>
<li><code>.disabled</code>：表示禁用状态</li>
</ul>
<p>只需要在相应的列表项上添加。<code>class=&quot;list-group-item active&quot;&gt;</code>，主要对于该项的背景颜色进行高亮，以及其中的<strong>徽章</strong>进行了<strong>高亮处理</strong></p>
<p>禁用状态，只是添加了一个灰色的背景色，以及文字的暗色处理</p>
<p>除了上面的两个最常用的状态之外，Bootstrap为我们的列表组也提供了不同的情景颜色，只需要在列表项中添加<code>.list-group-item-danger</code>这一系列的类。</p>
<h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><p>同样作为一个新增的组件，基础面板非常简单，就是一个div容器运用了<code>.panel</code>样式，产生一个具有边框的文本显示块。由于<code>.panel</code>不控制主题颜色，所以在<code>.panel</code>的基础上增加一个控制颜色的主题<code>.panel-default</code>，另外在里面添加了一个<code>.div.panel-body</code>来放置面板主体内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- panel-default就是那一系列的情景类，设置不同的可以设置不同的颜色 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span>我是一个基础面板，带有默认主题样式风格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="带有头和尾的面板"><a href="#带有头和尾的面板" class="headerlink" title="带有头和尾的面板"></a>带有头和尾的面板</h3><p>基础面板看上去太简单了，Bootstrap为了丰富面板的功能，特意为面板增加“面板头部”和“页面尾部”的效果：</p>
<ol>
<li><code>.panel-heading</code>：用来设置面板头部样式</li>
<li><code>.panel-footer</code>：用来设置面板尾部样式</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里对于不同的情景颜色，面板头的颜色改变十分明显 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span>图解CSS3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-footer"</span>&gt;</span>作者：大漠<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="面板中嵌套表格"><a href="#面板中嵌套表格" class="headerlink" title="面板中嵌套表格"></a>面板中嵌套表格</h3><p>其实面板作为一个用于处理，别的组件完成不了的情况的组件，一般情况下可以把面板理解为一个区域，所以在使用面板的时候，都会在<code>.panel-body</code>放置需要的内容，可能是<strong>图片、表格或者列表等</strong>。</p>
<p>如果在面板中嵌套表格，只需要将编写好的表格直接放置在面板中即可，不过有着如下两种形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span>图解CSS3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里是放在panel-body后面，实际上我们还可以将table放在panel-body里面 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-footer"</span>&gt;</span>作者：大漠<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>两个效果最大的差异是：</p>
<ol>
<li>放在<code>.panel-body</code><strong>内</strong>的表格，实际上就是简单的嵌套，设置了一些padding值等。</li>
<li>房在<code>.panel-body</code><strong>后</strong>的表格，会与面板融合在一起，与面板相接的地方，不会有着边框的展示，而是直接展示面板的边框</li>
</ol>
<p><strong>在面板中嵌套列表组时，同样是这样的两个差异</strong></p>
<hr>
<p>到这里我们的Bootstrap基础理论入门就结束了，实际上花了很多时间都是在理论上，并且中间还停歇了很长的时间。下一步我们需要做的就是在实战中去不断掌握它，了解它的细节，帮助我们能够缩短搭建时间、快速的搭建网站，并且让其在不同的终端下达到一个非常好的显示效果。</p>
<p>现在各个方面还是有很多不足，坚持学习，继续改进，加油！我的目标可是web全栈呢！</p>
<p>2016-03-01 01:40</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;博客之外&lt;/p&gt;
&lt;p&gt;只剩最后一天，二月份就结束了。距离上一篇博客已经有着整整一个月的时间，这一个月的时间，感觉技术上的成长又被搁置了，没有了之前闭关学习的心无旁骛，那段时间成长真的飞快。&lt;br&gt;在家喝酒，玩耍，到现在实习入职了一个星期，整整一个
    
    </summary>
    
      <category term="Bootstrap" scheme="http://guowenfh.github.io/categories/Bootstrap/"/>
    
    
      <category term="Bootstrap" scheme="http://guowenfh.github.io/tags/Bootstrap/"/>
    
  </entry>
  
</feed>
